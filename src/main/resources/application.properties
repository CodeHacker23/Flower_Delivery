# ============================================
# НАЗВАНИЕ ПРИЛОЖЕНИЯ
# ============================================
spring.application.name=Flower_Delivery

# ============================================
# НАСТРОЙКИ БАЗЫ ДАННЫХ (PostgreSQL)
# ============================================
# URL подключения к PostgreSQL
# Формат: jdbc:postgresql://localhost:5432/имя_базы
# localhost:5432 - стандартный адрес и порт PostgreSQL (не 3306 как у MySQL!)
# FlowerDeliwery - название базы данных (используем существующую базу из pgAdmin)
# PostgreSQL не поддерживает createDatabaseIfNotExist, поэтому базу нужно создать заранее!
# ВАЖНО: Имя базы чувствительно к регистру! Если у тебя "FlowerDeliwery" - пиши точно так же!
spring.datasource.url=jdbc:postgresql://localhost:5432/FlowerDeliwery
# Имя пользователя PostgreSQL (по умолчанию postgres, НЕ root как в MySQL!)
spring.datasource.username=postgres
# Пароль от PostgreSQL (замени на свой реальный пароль!)
# Если забыл пароль - смотри файл КАК_СБРОСИТЬ_ПАРОЛЬ.md
spring.datasource.password=12345
# Драйвер для подключения к PostgreSQL (это важно - без правильного драйвера не подключится!)
spring.datasource.driver-class-name=org.postgresql.Driver

# ============================================
# НАСТРОЙКИ JPA (Java Persistence API)
# ============================================
# Режим работы: validate - проверяет что таблицы соответствуют моделям
#               update - обновляет таблицы если модель изменилась
#               create - создает таблицы заново (удалит все данные!)
#               create-drop - создает при старте, удаляет при остановке
#               none - ничего не делает (используем Flyway вместо этого)
spring.jpa.hibernate.ddl-auto=none

# Показывать SQL запросы в консоли (для отладки)
# В продакшене поставь false, чтобы не засорять логи
spring.jpa.show-sql=true
# Форматировать SQL для читабельности
spring.jpa.properties.hibernate.format_sql=true

# Диалект PostgreSQL (говорит Hibernate как работать с PostgreSQL)
# Диалект - это язык общения между Hibernate и БД
# PostgreSQL имеет свои особенности SQL, которые Hibernate должен знать
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# ============================================
# НАСТРОЙКИ FLYWAY (Миграции БД)
# ============================================
# Включить Flyway (раскомментировано - приложение запустилось!)
spring.flyway.enabled=true
# Путь к папке с миграциями (SQL файлы)
spring.flyway.locations=classpath:db/migration
# Базовое имя схемы (для PostgreSQL указываем public - это стандартная схема)
# В PostgreSQL схема = это как "папка" в базе данных
# public - это схема по умолчанию, где хранятся все таблицы
spring.flyway.schemas=public
# Автоматически исправлять неправильные миграции (осторожно!)
# ВРЕМЕННО ВКЛЮЧЕНО для исправления контрольной суммы миграции V1
# После успешного запуска ПОСТАВЬ ОБРАТНО false!
spring.flyway.repair-on-migrate=true
# Кодировка SQL файлов
spring.flyway.encoding=UTF-8

# ============================================
# ТОКЕН TELEGRAM BOT (БЕЗОПАСНОСТЬ!)
# ============================================
# ВАЖНО:
# 1) Реальные токены и логины бота НЕ храним в гит-репозитории.
# 2) Здесь указываем только ссылки на переменные окружения.
# 3) Значения задаём в системе (Windows) или через конфигурацию IDE.
#
# Эти параметры читаются так:
# - TELEGRAM_BOT_TOKEN    -> реальный токен бота
# - TELEGRAM_BOT_USERNAME -> реальный username бота (без @)
#
# Примеры для локального запуска:
#   setx TELEGRAM_BOT_TOKEN "123456:ABCDEF..."
#   setx TELEGRAM_BOT_USERNAME "FlowerDelivery74bot"
#
# Если переменная окружения не задана — приложение упадёт при старте, это нормально:
# так ты не забудешь задать токен на сервере.

telegram.bot.token=${TELEGRAM_BOT_TOKEN}
telegram.bot.username=${TELEGRAM_BOT_USERNAME}

# ============================================
# НАСТРОЙКИ REDIS (пока закомментировано)
# ============================================
# Раскомментируй когда установишь Redis
# spring.data.redis.host=localhost
# spring.data.redis.port=6379
# spring.data.redis.password=
# spring.data.redis.timeout=2000ms

# ============================================
# ЛОГИРОВАНИЕ
# ============================================
# Уровень логирования (DEBUG, INFO, WARN, ERROR)
logging.level.org.example.flower_delivery=DEBUG
logging.level.org.springframework.web=INFO
logging.level.org.hibernate.SQL=DEBUG
