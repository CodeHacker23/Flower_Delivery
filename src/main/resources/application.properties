# ============================================
# НАЗВАНИЕ ПРИЛОЖЕНИЯ
# ============================================
spring.application.name=Flower_Delivery

# ============================================
# НАСТРОЙКИ БАЗЫ ДАННЫХ (PostgreSQL)
# ============================================
# URL подключения к PostgreSQL
# Формат: jdbc:postgresql://localhost:5432/имя_базы
# localhost:5432 - стандартный адрес и порт PostgreSQL (не 3306 как у MySQL!)
# FlowerDeliwery - название базы данных (используем существующую базу из pgAdmin)
# PostgreSQL не поддерживает createDatabaseIfNotExist, поэтому базу нужно создать заранее!
# ВАЖНО: Имя базы чувствительно к регистру! Если у тебя "FlowerDeliwery" - пиши точно так же!
spring.datasource.url=jdbc:postgresql://localhost:5432/FlowerDeliwery
# Имя пользователя PostgreSQL (по умолчанию postgres, НЕ root как в MySQL!)
spring.datasource.username=postgres
# Пароль от PostgreSQL (замени на свой реальный пароль!)
# Если забыл пароль - смотри файл КАК_СБРОСИТЬ_ПАРОЛЬ.md
spring.datasource.password=12345
# Драйвер для подключения к PostgreSQL (это важно - без правильного драйвера не подключится!)
spring.datasource.driver-class-name=org.postgresql.Driver

# ============================================
# НАСТРОЙКИ JPA (Java Persistence API)
# ============================================
# Режим работы: validate - проверяет что таблицы соответствуют моделям
#               update - обновляет таблицы если модель изменилась
#               create - создает таблицы заново (удалит все данные!)
#               create-drop - создает при старте, удаляет при остановке
#               none - ничего не делает (используем Flyway вместо этого)
# 
# РЕЖИМ ТЕСТИРОВАНИЯ: create-drop — каждый запуск = чистая БД
# ПРОДАКШН: поменяй на none и включи Flyway обратно!
spring.jpa.hibernate.ddl-auto=create-drop

# Показывать SQL запросы в консоли (для отладки)
# В продакшене поставь false, чтобы не засорять логи
spring.jpa.show-sql=true
# Форматировать SQL для читабельности
spring.jpa.properties.hibernate.format_sql=true

# Диалект PostgreSQL (говорит Hibernate как работать с PostgreSQL)
# Диалект - это язык общения между Hibernate и БД
# PostgreSQL имеет свои особенности SQL, которые Hibernate должен знать
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# ============================================
# НАСТРОЙКИ FLYWAY (Миграции БД)
# ============================================
# РЕЖИМ ТЕСТИРОВАНИЯ: Flyway выключен, Hibernate сам создаёт таблицы
# ПРОДАКШН: поменяй на true и ddl-auto на none!
spring.flyway.enabled=false
# Путь к папке с миграциями (SQL файлы)
spring.flyway.locations=classpath:db/migration
# Базовое имя схемы (для PostgreSQL указываем public - это стандартная схема)
# В PostgreSQL схема = это как "папка" в базе данных
# public - это схема по умолчанию, где хранятся все таблицы
spring.flyway.schemas=public
# Автоматически исправлять неправильные миграции (осторожно!)
# ВРЕМЕННО ВКЛЮЧЕНО для исправления контрольной суммы миграции V1
# После успешного запуска ПОСТАВЬ ОБРАТНО false!
spring.flyway.repair-on-migrate=true
# Кодировка SQL файлов
spring.flyway.encoding=UTF-8

# ============================================
# ТОКЕН TELEGRAM BOT (БЕЗОПАСНОСТЬ!)
# ============================================
# ВАЖНО:
# 1) Реальные токены и логины бота НЕ храним в гит-репозитории.
# 2) Здесь указываем только ссылки на переменные окружения.
# 3) Значения задаём в системе (Windows) или через конфигурацию IDE.
#
# Эти параметры читаются так:
# - TELEGRAM_BOT_TOKEN    -> реальный токен бота
# - TELEGRAM_BOT_USERNAME -> реальный username бота (без @)
#
# Примеры для локального запуска:
#   setx TELEGRAM_BOT_TOKEN "123456:ABCDEF..."
#   setx TELEGRAM_BOT_USERNAME "FlowerDelivery74bot"
#
# Если переменная окружения не задана — приложение упадёт при старте, это нормально:
# так ты не забудешь задать токен на сервере.

telegram.bot.token=${TELEGRAM_BOT_TOKEN}
telegram.bot.username=${TELEGRAM_BOT_USERNAME}

# ============================================
# НАСТРОЙКИ REDIS (пока закомментировано)
# ============================================
# Раскомментируй когда установишь Redis
# spring.data.redis.host=localhost
# spring.data.redis.port=6379
# spring.data.redis.password=
# spring.data.redis.timeout=2000ms

# ============================================
# ЛОГИРОВАНИЕ
# ============================================
# Уровень логирования (DEBUG, INFO, WARN, ERROR)
logging.level.org.example.flower_delivery=DEBUG
logging.level.org.springframework.web=INFO
logging.level.org.hibernate.SQL=DEBUG

# ============================================
# НАСТРОЙКИ РЕГИОНА (для мультирегиональности)
# ============================================
# Для другого региона (например, Екатеринбург) - просто поменяй эти значения:
# app.region.city=\u0415\u043a\u0430\u0442\u0435\u0440\u0438\u043d\u0431\u0443\u0440\u0433
# app.region.area=\u0421\u0432\u0435\u0440\u0434\u043b\u043e\u0432\u0441\u043a\u0430\u044f \u043e\u0431\u043b\u0430\u0441\u0442\u044c
# Unicode escape для кириллицы (Windows проблемы с UTF-8 в properties)
app.region.city=\u0427\u0435\u043b\u044f\u0431\u0438\u043d\u0441\u043a
app.region.area=\u0427\u0435\u043b\u044f\u0431\u0438\u043d\u0441\u043a\u0430\u044f \u043e\u0431\u043b\u0430\u0441\u0442\u044c

# ============================================
# DADATA API (Геокодирование)
# ============================================
# Бесплатно: 10 000 запросов/день
# Регистрация: https://dadata.ru/
dadata.api-key=d7274627133259fb1fe45a0ca68ae917f557e9e8
dadata.secret-key=29ed5280804687f786c89c20e05cebeb4d5250bb

# ============================================
# ТАРИФЫ ДОСТАВКИ (км -> рубли)
# ============================================
# Формат: app.tariffs.X=Y означает "до X км = Y рублей"
app.tariffs.3=300
app.tariffs.5=400
app.tariffs.7=500
app.tariffs.9=700
app.tariffs.11=850
app.tariffs.13=1000
app.tariffs.15=1150
app.tariffs.17=1300
app.tariffs.19=1450
app.tariffs.21=1550
app.tariffs.23=1650
app.tariffs.25=1750
app.tariffs.27=1850
app.tariffs.30=2000
