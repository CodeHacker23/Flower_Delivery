# РЕПОЗИТОРИЙ SHOPREPOSITORY — ПОЛНЫЙ ОБУЧАЮЩИЙ ГАЙД

**Тема:** Spring Data JPA-репозиторий для сущности `Shop`.  
**Файл:** `src/main/java/org/example/flower_delivery/repository/ShopRepository.java`

Разбираем каждую строчку: зачем интерфейс, как Spring понимает имена методов, что такое `Optional`, какие методы откуда берутся.

---

## СОДЕРЖАНИЕ

1. [Что такое репозиторий и зачем он](#что-такое-репозиторий)
2. [Строка за строкой: объявление интерфейса](#разбор-объявления)
3. [Как Spring «читает» имя метода и генерирует SQL](#как-spring-генерирует-sql)
4. [Optional — что это и зачем](#optional)
5. [Разбор каждого метода ShopRepository](#разбор-методов)
6. [Примеры использования в сервисе](#примеры-в-сервисе)

---

# ЧТО ТАКОЕ РЕПОЗИТОРИЙ

**Репозиторий** — прослойка между твоим кодом и БД. Ты вызываешь методы вроде `findByUserId(id)`, а кто-то должен выполнить запрос к таблице `shops` и вернуть результат.

- **Без Spring Data:** ты сам писал бы `entityManager.createQuery("SELECT s FROM Shop s WHERE s.user.id = :id", Shop.class).setParameter("id", id).getSingleResult()` и т.п.
- **С Spring Data:** объявляешь интерфейс с методом `Optional<Shop> findByUserId(UUID userId)` — реализацию и SQL Spring Data JPA генерирует сам по имени метода и полям сущности `Shop`.

Ты описываешь **что** нужно (найти магазин по `userId`), а **как** это сделать (какой SQL, как собрать объект) делает фреймворк.

---

# РАЗБОР ОБЪЯВЛЕНИЯ

```java
@Repository
public interface ShopRepository extends JpaRepository<Shop, UUID> {
```

## @Repository

- **Пакет:** `org.springframework.stereotype.Repository`
- **Смысл:** помечает класс (здесь — интерфейс репозитория) как «компонент доступа к данным». Spring создаёт бин и подставляет его туда, где запрошен `ShopRepository`.
- **Плюс:** при включённой обработке исключений Spring может переводить ошибки БД в свои иерархии (например, `DataAccessException`).

## interface ShopRepository

- Репозиторий — это **интерфейс**. Реализацию пишет не ты, а Spring Data JPA в рантайме.
- Имя `ShopRepository` — по сущности `Shop`, суффикс `Repository` — договорённость по стилю (так сразу видно, что это слой доступа к данным).

## extends JpaRepository<Shop, UUID>

- **JpaRepository<Entity, IdType>** — интерфейс из Spring Data JPA.
- **Первый тип — `Shop`:** с какой сущностью работаем (таблица `shops`).
- **Второй тип — `UUID`:** тип первичного ключа у `Shop` (поле `id`).

Из `JpaRepository` ты автоматически получаешь, среди прочего:

- `save(Shop entity)` — сохранить или обновить
- `findById(UUID id)` — `Optional<Shop>`
- `findAll()` — `List<Shop>`
- `delete(Shop entity)` / `deleteById(UUID id)`
- `existsById(UUID id)` — `boolean`
- `count()` — `long`

Дополнительные методы ты объявляешь сам — по имени метода Spring Data JPA сгенерирует запрос.

---

# КАК SPRING ГЕНЕРИРУЕТ SQL

Spring Data JPA смотрит на **имя метода** и на **поля сущности** (`Shop`, `User`) и по правилам строит запрос.

Общая схема имени метода:

```
[действие] + By + [поле1] + [And|Or] + [поле2] + …
```

- Начало: `find`, `exists`, `count`, `delete` и т.д.
- После `By` идёт описание условий по полям сущности и (при необходимости) связанных сущностей.

Важно: имена полей в методе пишутся в **CamelCase** так, как в классе сущности (`User`, `telegramId`, `isActive`), а не как колонки в БД (`user_id`, `telegram_id`, `is_active`). Маппинг колонок уже описан в `@Column`/`@JoinColumn` в сущностях.

Примеры для **Shop**:

- `findByUser(User user)`  
  Поле в `Shop`: `user`.  
  Условие: `WHERE shop.user_id = ?` (подставляется `user.getId()`).

- `findByUserId(UUID userId)`  
  Поле в `Shop`: `user` → у связанной сущности берётся `id`. В имени метода это выражается как `User` + `Id` = «поле user, его id».  
  Условие: `WHERE shop.user_id = ?`.

- `findByUserTelegramId(Long telegramId)`  
  Цепочка: у `Shop` есть поле `user` (тип `User`), у `User` есть поле `telegramId`.  
  В методе: `User` + `TelegramId` = «поле user, у него поле telegramId».  
  Запрос будет по связи `shop -> user` и по полю `users.telegram_id` (через join).  
  Условие по смыслу: «найти Shop, у которого user.telegramId = ?».

- `findByIsActiveTrue()`  
  Поле в `Shop`: `isActive`.  
  `True` в конце = условие `is_active = true`.  
  Условие: `WHERE shop.is_active = true`.

Подчёркивание (`findByUser_TelegramId`) используется, когда без него имя сливается в одно слово и разбор идёт неверно. У нас `findByUserTelegramId` разбирается как «user + telegramId», так что допускается и без подчёркивания.

---

# OPTIONAL

Сигнатуры вида `Optional<Shop> findByUserId(UUID userId)` возвращают не «Shop или null», а контейнер «значение есть или пусто».

## Зачем нужен Optional

- Явно показываем в API: «результат может отсутствовать».
- Меньше случайных `NullPointerException`: код вынужден явно обработать случай «ничего не найдено».

## Основные методы Optional

- `boolean isPresent()` — есть ли значение.
- `T get()` — вернуть значение; если пусто — исключение. Лучше не использовать без предварительной проверки.
- `T orElse(T other)` — вернуть значение или `other`, если пусто.
- `T orElseThrow()` — вернуть значение или выбросить исключение (удобно, когда «обязательно должен быть»).
- `T orElseThrow(Supplier<Exception>)` — то же, но своё исключение.
- `ifPresent(Consumer<T>)` — выполнить действие, только если значение есть.

Примеры:

```java
Optional<Shop> opt = shopRepository.findByUserId(userId);

if (opt.isPresent()) {
    Shop shop = opt.get();
    // работа с shop
}

// или
Shop shop = opt.orElse(null);

// или «обязан быть»
Shop shop = opt.orElseThrow(() -> new IllegalStateException("Магазин не найден"));
```

В сервисах для «обязательной» логики часто пишут `orElseThrow`, для «может не быть» — `isPresent` / `ifPresent` / `orElse`.

---

# РАЗБОР МЕТОДОВ SHOPREPOSITORY

## Optional&lt;Shop&gt; findByUser(User user)

- **Имя:** find + By + User.
- **Поле:** у `Shop` есть поле `user` (тип `User`). Условие — по этому полю (т.е. по `user_id` в БД).
- **SQL по смыслу:** `SELECT * FROM shops WHERE user_id = ?` (в параметр подставляется `user.getId()`).
- **Возврат:** `Optional<Shop>`, потому что связь 1:1 — либо один магазин, либо ни одного.

Использование: когда уже есть объект `User` и нужно получить его магазин.

---

## Optional&lt;Shop&gt; findByUserId(UUID userId)

- **Имя:** find + By + User + Id.
- **Поле:** у `Shop` поле `user`; берётся его `id`. В методе это кодируется как `UserId`.
- **SQL по смыслу:** `SELECT * FROM shops WHERE user_id = ?`.
- **Возврат:** `Optional<Shop>` — один магазин или пусто.

Использование: когда есть только `users.id` (UUID пользователя), а не объект `User`.

---

## Optional&lt;Shop&gt; findByUserTelegramId(Long telegramId)

- **Имя:** find + By + User + TelegramId.
- **Цепочка:** у `Shop` поле `user`, у `User` поле `telegramId`. Условие — по связанной таблице и полю.
- **SQL по смыслу:** join `shops` с `users` по `user_id`, затем `WHERE users.telegram_id = ?`.
- **Возврат:** `Optional<Shop>`.

Использование: типичный случай в боте — пришёл `telegram_id` из сообщения, по нему нужно получить магазин пользователя.

---

## List&lt;Shop&gt; findByIsActiveTrue()

- **Имя:** find + By + IsActive + True.
- **Поле:** у `Shop` есть `isActive` (Boolean). `True` в конце — это константа «истина» в условии.
- **SQL по смыслу:** `SELECT * FROM shops WHERE is_active = true`.
- **Возврат:** `List<Shop>`, потому что магазинов может быть несколько.

Использование: списки активных магазинов для админа или отчётов.

---

# ПРИМЕРЫ В СЕРВИСЕ

Как это будет выглядеть в `ShopService`:

```java
// по telegram_id из Telegram-сообщения
public Optional<Shop> findByTelegramId(Long telegramId) {
    return shopRepository.findByUserTelegramId(telegramId);
}

// по пользователю, если он уже загружен
public Optional<Shop> findByUser(User user) {
    return shopRepository.findByUser(user);
}

// проверка «уже есть магазин у этого пользователя?»
public boolean existsByUserId(UUID userId) {
    return shopRepository.findByUserId(userId).isPresent();
    // или лучше завести в репозитории: boolean existsByUserId(UUID userId);
}
```

Дальше в коде регистрации магазина будешь вызывать, например, `findByUserTelegramId(telegramId)` и по `Optional` решать: создавать новый магазин или обновлять существующий.

---

## Краткая шпаргалка по методам

| Метод в ShopRepository    | Условие в SQL               | Возврат           | Когда использовать        |
|---------------------------|-----------------------------|-------------------|---------------------------|
| findByUser(User)          | user_id = ?                 | Optional&lt;Shop&gt; | Есть объект User          |
| findByUserId(UUID)        | user_id = ?                 | Optional&lt;Shop&gt; | Есть только users.id      |
| findByUserTelegramId(Long)| users.telegram_id = ? (join)| Optional&lt;Shop&gt; | Есть telegram_id из бота  |
| findByIsActiveTrue()     | is_active = true            | List&lt;Shop&gt;     | Список активных магазинов |

---

Дальше по плану — **ShopService**: там вызываем эти методы репозитория, добавляем логику «создать магазин», «найти магазин по telegram_id» и т.п. Когда будешь готов — можно переходить к сервису.
