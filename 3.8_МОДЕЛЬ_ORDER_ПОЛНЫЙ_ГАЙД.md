# 🎓 МОДЕЛЬ ORDER — ПОЛНЫЙ ГАЙД ОТ "ЧТО ЭТО НАХУЙ" ДО "ТЕПЕРЬ Я БОГ JPA"

**Версия:** 1.0 — Тотальное погружение в Entity  
**Стиль:** Жёстко, с юмором, но чтобы в башке осталось навсегда

---

# 📋 СОДЕРЖАНИЕ

1. [Что такое Entity и нахуя оно нужно](#часть-1-что-такое-entity)
2. [ORM — магия превращения таблиц в объекты](#часть-2-orm)
3. [JPA vs Hibernate — кто есть кто](#часть-3-jpa-vs-hibernate)
4. [Разбор Order.java — каждая сука строчка](#часть-4-разбор-orderjava)
5. [Связи между таблицами — @ManyToOne и компания](#часть-5-связи)
6. [Практические задания](#часть-6-практика)

---

# ЧАСТЬ 1: ЧТО ТАКОЕ ENTITY

## Проблема: Два мира

У нас есть **два мира**, которые нихуя друг о друге не знают:

### Мир Java (объекты):
```java
Order order = new Order();
order.setRecipientName("Анна");
order.setDeliveryAddress("Ленина 10");
```

### Мир SQL (таблицы):
```sql
INSERT INTO orders (recipient_name, delivery_address)
VALUES ('Анна', 'Ленина 10');
```

**Проблема:** Java не знает SQL, SQL не знает Java. Как их подружить?

---

## Решение: Entity

**Entity** (сущность) — это Java-класс, который **представляет таблицу в БД**.

```
┌─────────────────────────────────────────────────────────────┐
│                         JAVA                                 │
│                                                              │
│   class Order {           ←───── Entity-класс               │
│       UUID id;                                               │
│       String recipientName;                                  │
│       String deliveryAddress;                                │
│   }                                                          │
│                           │                                  │
│                           │ JPA/Hibernate                    │
│                           │ (автоматически переводит)        │
│                           ▼                                  │
├─────────────────────────────────────────────────────────────┤
│                       БАЗА ДАННЫХ                            │
│                                                              │
│   CREATE TABLE orders (   ←───── Таблица                    │
│       id UUID,                                               │
│       recipient_name VARCHAR,                                │
│       delivery_address VARCHAR                               │
│   );                                                         │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**Одна строка в таблице = один объект в Java.**

---

## Аналогия: Excel и программа

Представь:
- **Таблица в БД** = Excel-файл с данными
- **Entity-класс** = Программа, которая умеет читать/писать этот Excel

Без Entity тебе пришлось бы вручную:
1. Писать SQL-запросы
2. Парсить результаты
3. Создавать объекты
4. Следить за изменениями

**С Entity это делается автоматически.** Ты работаешь с объектами, а JPA сам генерирует SQL.

---

# ЧАСТЬ 2: ORM

## Что такое ORM

**ORM** = Object-Relational Mapping (Объектно-реляционное отображение).

Это **концепция** (не библиотека!) — идея о том, что:
- Таблицы можно представить как классы
- Строки можно представить как объекты
- Колонки можно представить как поля

```
ТАБЛИЦА orders          КЛАСС Order
┌────┬───────────┐      ┌─────────────────┐
│ id │ name      │      │ class Order {   │
├────┼───────────┤  ═══▶│   UUID id;      │
│ 1  │ "Анна"    │      │   String name;  │
│ 2  │ "Мария"   │      │ }               │
└────┴───────────┘      └─────────────────┘

СТРОКА                   ОБЪЕКТ
id=1, name="Анна"   ═══▶ new Order(1, "Анна")
```

---

## Зачем ORM нужен

### Без ORM (ад и боль):

```java
// Хочешь сохранить заказ? Пиши SQL руками:
String sql = "INSERT INTO orders (recipient_name, delivery_address, price) VALUES (?, ?, ?)";
PreparedStatement stmt = connection.prepareStatement(sql);
stmt.setString(1, order.getRecipientName());
stmt.setString(2, order.getDeliveryAddress());
stmt.setBigDecimal(3, order.getDeliveryPrice());
stmt.executeUpdate();

// Хочешь прочитать? Опять SQL и парсинг:
ResultSet rs = stmt.executeQuery("SELECT * FROM orders WHERE id = ?");
if (rs.next()) {
    Order order = new Order();
    order.setId(rs.getObject("id", UUID.class));
    order.setRecipientName(rs.getString("recipient_name"));
    order.setDeliveryAddress(rs.getString("delivery_address"));
    // ... и так для каждого поля, блять
}
```

### С ORM (кайф):

```java
// Сохранить:
orderRepository.save(order);  // Всё. Одна строка.

// Прочитать:
Order order = orderRepository.findById(id).orElseThrow();  // Всё.
```

**ORM делает за тебя всю грязную работу с SQL.**

---

# ЧАСТЬ 3: JPA vs HIBERNATE

## JPA — это спецификация

**JPA** (Java Persistence API) — это **стандарт**, набор интерфейсов и аннотаций.

JPA говорит: "Если хочешь делать ORM в Java — вот аннотации которые нужно использовать":
- `@Entity` — пометить класс как сущность
- `@Table` — указать имя таблицы
- `@Id` — пометить первичный ключ
- `@Column` — настроить колонку

**Но JPA — это только бумажка с правилами!** Сам по себе он ничего не делает.

---

## Hibernate — это реализация

**Hibernate** — это **библиотека**, которая реализует стандарт JPA.

```
┌─────────────────────────────────────────┐
│              JPA (стандарт)              │
│  "Аннотация @Entity должна означать..." │
│  "Аннотация @Id должна означать..."     │
└─────────────────────────────────────────┘
                    │
                    │ реализует
                    ▼
┌─────────────────────────────────────────┐
│           Hibernate (библиотека)         │
│  "Окей, вижу @Entity — создам таблицу"  │
│  "Вижу @Id — сделаю PRIMARY KEY"        │
│  "Генерирую SQL и выполняю"             │
└─────────────────────────────────────────┘
```

**Аналогия:**
- **JPA** = ПДД (правила дорожного движения)
- **Hibernate** = Водитель, который соблюдает эти правила

Есть и другие реализации JPA (EclipseLink, OpenJPA), но Hibernate — самая популярная. Spring Boot использует Hibernate по умолчанию.

---

## Spring Data JPA — ещё один уровень

**Spring Data JPA** — это обёртка над JPA/Hibernate от Spring.

Она добавляет магию репозиториев:

```java
// Ты пишешь только интерфейс:
public interface OrderRepository extends JpaRepository<Order, UUID> {
    List<Order> findByStatus(OrderStatus status);
}

// Spring Data JPA САМА генерирует реализацию!
// Тебе не нужно писать ни строчки SQL!
```

**Иерархия:**
```
Spring Data JPA (магия репозиториев)
       │
       ▼
      JPA (стандарт аннотаций)
       │
       ▼
   Hibernate (реализация, генерация SQL)
       │
       ▼
     JDBC (низкоуровневое соединение с БД)
       │
       ▼
   PostgreSQL (сама база данных)
```

---

# ЧАСТЬ 4: РАЗБОР ORDER.JAVA

Теперь разберём твой код **построчно**.

---

## Строка 1: Package

```java
package org.example.flower_delivery.model;
```

**Что это:** Объявление пакета.

**Зачем:** 
- Группировка классов (все модели в `model`)
- Избежание конфликтов имён
- Структура проекта

**Конвенция:**
- `model` — Entity-классы (Order, User, Shop)
- `repository` — интерфейсы для работы с БД
- `service` — бизнес-логика
- `handler` — обработчики событий бота

---

## Строки 3-10: Импорты

```java
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;
```

### `jakarta.persistence.*`

Это **JPA-аннотации**. Раньше был `javax.persistence`, но с Java 17+ переименовали в `jakarta`.

Что внутри:
- `@Entity`, `@Table` — для класса
- `@Id`, `@GeneratedValue` — для первичного ключа
- `@Column` — для настройки колонок
- `@ManyToOne`, `@JoinColumn` — для связей
- `@Enumerated` — для enum-полей

### `lombok.*`

Lombok — библиотека для генерации boilerplate-кода:
- `@Getter` — генерирует getter для каждого поля
- `@Setter` — генерирует setter для каждого поля
- `@NoArgsConstructor` — конструктор без параметров
- `@AllArgsConstructor` — конструктор со всеми параметрами
- `@Builder` — паттерн Builder для создания объектов

### `org.hibernate.annotations.*`

Специфичные аннотации Hibernate (не часть JPA-стандарта):
- `@CreationTimestamp` — автоматически ставит время создания
- `@UpdateTimestamp` — автоматически обновляет время изменения

### Типы данных

- `BigDecimal` — для денег (точные вычисления, без погрешностей float/double)
- `LocalDateTime` — дата + время (Java 8+)
- `UUID` — универсальный уникальный идентификатор (лучше чем Long для распределённых систем)

---

## Строки 12-19: Аннотации класса

```java
@Entity
@Table(name = "orders")
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class Order {
```

### `@Entity`

**Что делает:** Помечает класс как JPA-сущность.

**Под капотом:**
1. Hibernate сканирует классы при запуске
2. Находит `@Entity`
3. Понимает: "Это таблица в БД"
4. Создаёт метаданные для работы с этим классом

**Без @Entity:**
```java
orderRepository.save(order);  // Ошибка! Hibernate не знает что это.
```

### `@Table(name = "orders")`

**Что делает:** Указывает имя таблицы в БД.

**Зачем:** По умолчанию Hibernate использует имя класса (`Order`), но:
- `ORDER` — зарезервированное слово в SQL!
- `SELECT * FROM ORDER` — синтаксическая ошибка
- Поэтому называем таблицу `orders` (множественное число)

**Параметры @Table:**
```java
@Table(
    name = "orders",           // имя таблицы
    schema = "public",         // схема (опционально)
    uniqueConstraints = {...}  // уникальные ограничения (опционально)
)
```

### `@Getter` и `@Setter` (Lombok)

**Что генерирует:**
```java
// Lombok генерирует для каждого поля:
public UUID getId() {
    return this.id;
}

public void setId(UUID id) {
    this.id = id;
}
// ... и так для всех полей
```

**Зачем:** 
- Меньше boilerplate-кода
- Класс остаётся чистым и читаемым
- Изменил поле — getter/setter обновятся автоматически

### `@NoArgsConstructor`

**Что генерирует:**
```java
public Order() {
    // пустой конструктор
}
```

**ВАЖНО для JPA:** Hibernate ТРЕБУЕТ пустой конструктор! Он создаёт объекты через рефлексию:
```java
Order order = Order.class.getDeclaredConstructor().newInstance();
```

Без пустого конструктора — ошибка при запуске.

### `@AllArgsConstructor`

**Что генерирует:**
```java
public Order(UUID id, Shop shop, User courier, String recipientName, 
             String recipientPhone, ... все поля ...) {
    this.id = id;
    this.shop = shop;
    // ... присваивание всех полей
}
```

### `@Builder`

**Что генерирует:** Паттерн Builder — удобный способ создания объектов.

```java
// Без Builder (неудобно):
Order order = new Order();
order.setRecipientName("Анна");
order.setRecipientPhone("+79991234567");
order.setDeliveryAddress("Ленина 10");
order.setDeliveryPrice(new BigDecimal("500"));
// ... 10 сеттеров подряд, легко забыть что-то

// С Builder (красиво):
Order order = Order.builder()
        .recipientName("Анна")
        .recipientPhone("+79991234567")
        .deliveryAddress("Ленина 10")
        .deliveryPrice(new BigDecimal("500"))
        .build();
```

**Преимущества Builder:**
1. Читаемость — видно что устанавливаем
2. Необязательные поля — пропускаем что не нужно
3. Иммутабельность — объект создаётся целиком, а не по частям

---

## Строки 24-27: Первичный ключ

```java
@Id
@GeneratedValue(strategy = GenerationType.UUID)
@Column(name = "id", nullable = false, updatable = false)
private UUID id;
```

### `@Id`

**Что делает:** Помечает поле как PRIMARY KEY.

**Правила:**
- Каждая Entity ДОЛЖНА иметь `@Id`
- `@Id` должен быть уникальным
- По `@Id` Hibernate различает объекты

### `@GeneratedValue(strategy = GenerationType.UUID)`

**Что делает:** Говорит как генерировать значение ID.

**Стратегии:**
```java
GenerationType.UUID      // UUID (наш выбор)
GenerationType.IDENTITY  // Автоинкремент БД (1, 2, 3...)
GenerationType.SEQUENCE  // Sequence в БД
GenerationType.AUTO      // Hibernate сам выберет
```

**Почему UUID, а не Long:**
- UUID уникален глобально (можно генерировать на клиенте)
- Нет проблем с распределёнными системами
- Сложнее угадать ID (безопасность)
- Недостаток: больше места (16 байт vs 8 байт)

### `@Column(...)`

**Параметры:**
```java
@Column(
    name = "id",           // имя колонки в БД
    nullable = false,      // NOT NULL
    updatable = false      // нельзя изменить после создания
)
```

**`updatable = false`** — ID никогда не меняется. Это защита от случайного `order.setId(...)`.

---

## Строки 36-48: Связи с другими таблицами

```java
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "shop_id", nullable = false)
private Shop shop;

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "courier_id")
private User courier;
```

### `@ManyToOne`

**Что это:** Связь "Много к одному".

**В контексте Order:**
- **Много** заказов → **один** магазин
- **Много** заказов → **один** курьер

```
┌─────────┐         ┌─────────┐
│  ORDER  │ N     1 │  SHOP   │
│─────────│─────────│─────────│
│ shop_id │────────▶│ id      │
└─────────┘         └─────────┘

Много заказов ссылаются на один магазин
```

### `FetchType.LAZY`

**Что это:** Стратегия загрузки связанных данных.

**LAZY (ленивая):**
```java
Order order = orderRepository.findById(id);
// SQL: SELECT * FROM orders WHERE id = ?
// Shop НЕ загружен!

order.getShop().getName();  // Только сейчас:
// SQL: SELECT * FROM shops WHERE id = ?
```

**EAGER (жадная):**
```java
Order order = orderRepository.findById(id);
// SQL: SELECT * FROM orders o JOIN shops s ON o.shop_id = s.id WHERE o.id = ?
// Shop сразу загружен!
```

**Почему LAZY лучше:**
- Не грузим лишние данные
- Быстрее запросы
- Меньше памяти

**Правило:** Всегда используй `LAZY`, если не уверен.

### `@JoinColumn`

**Что это:** Настройка колонки-ссылки (Foreign Key).

```java
@JoinColumn(
    name = "shop_id",      // имя колонки в таблице orders
    nullable = false       // NOT NULL (заказ обязан иметь магазин)
)
```

**Для courier `nullable` не указан** (по умолчанию `true`):
```java
@JoinColumn(name = "courier_id")  // NULL разрешён
private User courier;              // Заказ может быть без курьера (статус NEW)
```

---

## Строки 125-127: Enum поля

```java
@Enumerated(EnumType.STRING)
@Column(name = "delivery_interval", nullable = false, length = 20)
private DeliveryInterval deliveryInterval;
```

### `@Enumerated(EnumType.STRING)`

**Что это:** Как сохранять enum в БД.

**Два варианта:**

```java
// EnumType.STRING — сохраняет как строку:
// В БД: "MORNING", "DAY", "EVENING"
@Enumerated(EnumType.STRING)
private DeliveryInterval deliveryInterval;

// EnumType.ORDINAL — сохраняет как число (позиция в enum):
// В БД: 0, 1, 2
@Enumerated(EnumType.ORDINAL)
private DeliveryInterval deliveryInterval;
```

**НИКОГДА не используй ORDINAL!**

Почему:
```java
// Было:
enum DeliveryInterval { MORNING, DAY, EVENING }
// В БД: MORNING=0, DAY=1, EVENING=2

// Добавили новый интервал В НАЧАЛО:
enum DeliveryInterval { ASAP, MORNING, DAY, EVENING }
// Теперь: ASAP=0, MORNING=1, DAY=2, EVENING=3

// Все старые записи СЛОМАЛИСЬ:
// Было DAY=1, стало MORNING=1
// Пиздец данным.
```

**STRING безопасен** — порядок элементов не важен.

---

## Строки 146-149: Значение по умолчанию

```java
@Enumerated(EnumType.STRING)
@Column(name = "status", nullable = false, length = 20)
@Builder.Default
private OrderStatus status = OrderStatus.NEW;
```

### `@Builder.Default`

**Проблема с @Builder:**
```java
// Без @Builder.Default:
Order order = Order.builder()
        .recipientName("Анна")
        // забыли .status(...)
        .build();
// order.status = null!  Хотя в поле написано = OrderStatus.NEW

// Почему? Builder игнорирует инициализаторы полей!
```

**С @Builder.Default:**
```java
@Builder.Default
private OrderStatus status = OrderStatus.NEW;

Order order = Order.builder()
        .recipientName("Анна")
        // не указали status
        .build();
// order.status = OrderStatus.NEW  ✅ Значение по умолчанию работает!
```

---

## Строки 158-167: Временные метки

```java
@CreationTimestamp
@Column(name = "created_at", nullable = false, updatable = false)
private LocalDateTime createdAt;

@UpdateTimestamp
@Column(name = "updated_at", nullable = false)
private LocalDateTime updatedAt;
```

### `@CreationTimestamp` (Hibernate)

**Что делает:** Автоматически ставит текущее время при **создании** записи.

```java
Order order = Order.builder().recipientName("Анна").build();
orderRepository.save(order);
// order.createdAt = 2025-01-26T15:30:00  (автоматически!)
```

**`updatable = false`** — дата создания никогда не меняется.

### `@UpdateTimestamp` (Hibernate)

**Что делает:** Автоматически обновляет время при **каждом изменении**.

```java
order.setStatus(OrderStatus.DELIVERED);
orderRepository.save(order);
// order.updatedAt = 2025-01-26T16:45:00  (обновилось!)
```

---

## Строки 197-215: Вспомогательные методы

```java
public boolean hasCourier() {
    return courier != null;
}

public boolean isAvailable() {
    return status == OrderStatus.NEW;
}

public boolean isCompleted() {
    return status == OrderStatus.DELIVERED ||
           status == OrderStatus.RETURNED ||
           status == OrderStatus.CANCELLED;
}
```

### Зачем эти методы

**Инкапсуляция логики.** Вместо проверок в 100 местах:

```java
// Плохо (дублирование):
if (order.getStatus() == OrderStatus.DELIVERED || 
    order.getStatus() == OrderStatus.RETURNED ||
    order.getStatus() == OrderStatus.CANCELLED) {
    // ...
}

// Хорошо (инкапсуляция):
if (order.isCompleted()) {
    // ...
}
```

**Преимущества:**
1. Код читается как текст: `order.isCompleted()` понятнее чем куча условий
2. Изменения в одном месте — если добавится новый финальный статус, меняем только метод
3. Тестируемость — можно написать unit-тест на метод

---

# ЧАСТЬ 5: СВЯЗИ

## Типы связей в JPA

### @OneToOne — Один к одному

```
USER 1 ←────→ 1 SHOP
Один юзер = один магазин
```

```java
// В Shop.java:
@OneToOne
@JoinColumn(name = "user_id")
private User user;
```

### @OneToMany — Один ко многим

```
SHOP 1 ←────→ N ORDER
Один магазин = много заказов
```

```java
// В Shop.java (если нужен список заказов):
@OneToMany(mappedBy = "shop")
private List<Order> orders;
```

### @ManyToOne — Много к одному

```
ORDER N ←────→ 1 SHOP
Много заказов = один магазин
```

```java
// В Order.java:
@ManyToOne
@JoinColumn(name = "shop_id")
private Shop shop;
```

### @ManyToMany — Много ко многим

```
STUDENT N ←────→ N COURSE
Много студентов = много курсов
```

```java
@ManyToMany
@JoinTable(name = "student_courses",
    joinColumns = @JoinColumn(name = "student_id"),
    inverseJoinColumns = @JoinColumn(name = "course_id"))
private List<Course> courses;
```

---

## Визуально наши связи:

```
┌──────────────────────────────────────────────────────────────┐
│                                                               │
│   ┌────────┐    1:1    ┌────────┐    1:N    ┌────────┐       │
│   │  USER  │◄─────────▶│  SHOP  │◄─────────▶│ ORDER  │       │
│   │────────│           │────────│           │────────│       │
│   │ id     │           │ id     │           │ id     │       │
│   │ role   │           │ user_id│           │ shop_id│       │
│   └────────┘           └────────┘           │courier_│       │
│       ▲                                     │  id    │       │
│       │                                     └────────┘       │
│       │                                          │           │
│       │              N:1 (курьер)                │           │
│       └──────────────────────────────────────────┘           │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

---

# ЧАСТЬ 6: ПРАКТИКА

## Задание 1: Понимание аннотаций

**Вопрос:** Что произойдёт, если убрать `@Entity` с класса Order?

<details>
<summary>Ответ</summary>

Hibernate не будет знать что Order — это таблица. 
При попытке `orderRepository.save(order)` получим ошибку:
```
Unknown entity: org.example.flower_delivery.model.Order
```

</details>

---

## Задание 2: FetchType

**Вопрос:** Что произойдёт при выполнении этого кода, если FetchType.LAZY?

```java
Order order = orderRepository.findById(id).orElseThrow();
System.out.println(order.getShop().getName());
```

<details>
<summary>Ответ</summary>

1. Первый SQL: `SELECT * FROM orders WHERE id = ?`
2. `order.getShop()` — возвращает proxy-объект (не настоящий Shop!)
3. `.getName()` — Hibernate понимает, что нужны данные
4. Второй SQL: `SELECT * FROM shops WHERE id = ?`
5. Выводится имя магазина

Это называется "ленивая загрузка" — данные грузятся только когда реально нужны.

</details>

---

## Задание 3: Напиши OrderRepository

Теперь, когда ты понимаешь что такое Entity, напиши репозиторий.

**Файл:** `src/main/java/org/example/flower_delivery/repository/OrderRepository.java`

**Требования:**
1. Интерфейс, наследует `JpaRepository<Order, UUID>`
2. Аннотация `@Repository`
3. Методы:
   - `findByShop(Shop shop)` — найти заказы магазина
   - `findByStatus(OrderStatus status)` — найти по статусу
   - `findByCourier(User courier)` — найти заказы курьера
   - `countByShop(Shop shop)` — посчитать заказы магазина

**Подсказка:** Посмотри как сделан `ShopRepository.java`.

---

## Задание 4: Напиши OrderService

После репозитория напиши сервис.

**Файл:** `src/main/java/org/example/flower_delivery/service/OrderService.java`

**Требования:**
1. Аннотации: `@Slf4j`, `@Service`, `@RequiredArgsConstructor`
2. Зависимость: `private final OrderRepository orderRepository;`
3. Методы:
   - `createOrder(...)` — создать заказ
   - `findById(UUID id)` — найти по ID
   - `getOrdersByShop(Shop shop)` — список заказов магазина
   - `getAvailableOrders()` — свободные заказы (статус NEW)

---

**Напиши эти два файла и скинь — проверю!**

---

# 🎯 ИТОГО

Теперь ты знаешь:

1. **Entity** — Java-класс, представляющий таблицу в БД
2. **ORM** — концепция маппинга объектов на таблицы
3. **JPA** — стандарт (аннотации), **Hibernate** — реализация
4. **@Entity, @Table, @Id, @Column** — основные аннотации
5. **@ManyToOne, @JoinColumn** — связи между таблицами
6. **@Enumerated(EnumType.STRING)** — как хранить enum
7. **@Builder.Default** — значения по умолчанию для Builder
8. **FetchType.LAZY** — ленивая загрузка связей

**Entity — это мост между Java и SQL. Ты работаешь с объектами, Hibernate работает с таблицами.** 🚀
