# Редактирование и отмена заказа — пошагово

## Что мы делаем в итоге

1. **Мои заказы** — под каждым заказом две кнопки: [✏️ Редактировать] [❌ Отменить].
2. **Отменить** — спрашиваем «Точно отменить?», по «Да» — ставим статус CANCELLED.
3. **Редактировать** — показываем «Какую точку?» (для мультиадреса) или сразу «Что изменить?», потом просим ввести новое значение и сохраняем.

Кнопка «Главное меню» остаётся внизу экрана (Reply-клавиатура), её не трогаем.

---

## Почему inline-кнопки

- **Inline-кнопки** привязаны к сообщению. При нажатии Telegram присылает **CallbackQuery** с полем `data` — туда мы кладём, например, `order_cancel_abc-123-uuid`. По этому строке мы понимаем: отменить заказ с id = abc-123-uuid.
- **Reply-кнопки** при нажатии присылают обычное **текстовое сообщение** (например "❌ Отменить заказ"). Тогда мы не знаем, *какой именно* заказ отменить — нужен был бы отдельный шаг «введите номер заказа». Поэтому под каждым заказом делаем именно inline: у каждой кнопки свой `callback_data` с id заказа.

---

## Что такое callback_data и зачем формат

`callback_data` — строка до **64 байт**, которую мы сами задаём при создании кнопки. Telegram её не меняет, просто при нажатии присылает обратно.

Договоримся о формате, чтобы по строке однозначно понимать действие:

| Что делаем              | Формат                    | Пример                          |
|-------------------------|---------------------------|---------------------------------|
| Редактировать заказ     | `order_edit_{orderId}`    | `order_edit_a1b2c3-...`         |
| Отменить заказ          | `order_cancel_{orderId}`  | `order_cancel_a1b2c3-...`       |
| Подтвердить отмену      | `order_cancel_ok_{orderId}` | `order_cancel_ok_a1b2c3-...`  |
| Отмена отмены           | `order_cancel_no`         | без id                          |
| Выбрать точку для правки| `order_edit_{orderId}_stop_{N}` | `order_edit_xxx_stop_1`   |
| Выбрать поле точки      | `order_edit_{orderId}_stop_{N}_{field}` | `order_edit_xxx_stop_1_address` |

`orderId` — UUID заказа (36 символов). Итого префикс + uuid уже ~50 символов, поэтому остальные суффиксы короткие: `_stop_1`, `_address`.

---

## ШАГ 1: Под списком «Мои заказы» показать inline-кнопки

**Где:** `Bot.java`, метод `handleMyOrdersButton`.

**Что сейчас:** формируется текст списка заказов и отправляется через `sendSimpleMessage(chatId, sb.toString())` — без клавиатуры.

**Что нужно:** для каждого заказа добавить **ряд из двух кнопок** (Редактировать, Отменить). Один ряд = один заказ. Всю клавиатуру передать в то же сообщение.

**Как устроена Inline-клавиатура:**

- Клавиатура = список рядов (`List<List<InlineKeyboardButton>>`).
- Один ряд = список кнопок в строке (`List<InlineKeyboardButton>`).
- Кнопка: текст (что видит пользователь) + `callback_data` (что получим при нажатии).

Пример для одного заказа:

```java
// Один заказ — один ряд кнопок
InlineKeyboardButton btnEdit = InlineKeyboardButton.builder()
    .text("✏️ Редактировать")
    .callbackData("order_edit_" + order.getId().toString())
    .build();
InlineKeyboardButton btnCancel = InlineKeyboardButton.builder()
    .text("❌ Отменить")
    .callbackData("order_cancel_" + order.getId().toString())
    .build();

// Ряд = две кнопки рядом
keyboard.add(List.of(btnEdit, btnCancel));
```

**Важно:** сообщение с инлайн-кнопками нужно отправлять не через `sendSimpleMessage` (там нет клавиатуры), а через `SendMessage` с `setReplyMarkup(InlineKeyboardMarkup)`. То есть в `Bot.java` понадобится метод вроде `sendMessageWithInlineKeyboard(chatId, text, keyboard)` или добавить в существующий отправки вызов `setReplyMarkup`.

**Порядок в коде:**

1. Создать `List<List<InlineKeyboardButton>> keyboard = new ArrayList<>()`.
2. В цикле по заказам для каждого заказа создавать два `InlineKeyboardButton` (Редактировать / Отменить) с `callback_data` как выше и добавлять `keyboard.add(List.of(btnEdit, btnCancel))`.
3. Собрать `InlineKeyboardMarkup` из `keyboard`.
4. Создать `SendMessage`, установить текст (как сейчас `sb.toString()`), установить `setReplyMarkup(keyboardMarkup)` и отправить через `execute(sendMessage)`.

После этого под списком «Мои заказы» появятся кнопки. Пока что при нажатии они будут «неизвестная команда» — обработаем в шаге 2.

---

## ШАГ 2: Обработать нажатие «Отменить заказ»

**Где:** `CallbackQueryHandler.handle()` — разбор `callbackData`.

**Что делать при `order_cancel_{orderId}`:**

1. Ответить на callback: `answerCallbackQuery(callbackQuery.getId(), "Отменить заказ?");` (чтобы убрать «часики» у кнопки).
2. Отправить в чат новое сообщение с текстом вроде: «Вы уверены, что хотите отменить этот заказ?» и двумя inline-кнопками:
   - [Да, отменить] — `callback_data = "order_cancel_ok_" + orderId`
   - [Нет] — `callback_data = "order_cancel_no"`

**Что делать при `order_cancel_ok_{orderId}`:**

1. По `orderId` найти заказ в БД (через `OrderService` / `OrderRepository`).
2. Проверить, что статус заказа = NEW (отменять можно только такие).
3. Поставить статус CANCELLED и сохранить.
4. Ответить пользователю: «Заказ отменён» и при желании снова показать список заказов (как в «Мои заказы», но уже без этого заказа или с пометкой «Отменён» — как решишь).

**Что делать при `order_cancel_no`:**

- Просто ответить «Ок, заказ не отменён» или удалить сообщение с подтверждением — как тебе удобнее.

В `CallbackQueryHandler` в блоке `if (callbackData.startsWith(...))` добавь ветки:

- `callbackData.startsWith("order_cancel_ok_")` — снять id, отменить заказ, отправить ответ.
- `callbackData.startsWith("order_cancel_")` — показать подтверждение (здесь же различай «показать подтверждение» и «подтвердил отмену» по наличию `_ok_` в строке).
- `callbackData.equals("order_cancel_no")` — отмена действия.

Так завершится сценарий «Мои заказы → Отменить → Да/Нет».

---

## ШАГ 3: Обработать нажатие «Редактировать заказ»

Здесь два подшага: показать меню выбора (точка / поле) и принять от пользователя новое значение (текст).

### 3.1. Показать меню редактирования

**При `order_edit_{orderId}`:**

1. По `orderId` загрузить заказ и его точки (если мультиадрес).
2. Если точек одна (обычный заказ или мультиадрес с одной точкой):
   - Отправить сообщение: «Что хотите изменить?» и кнопки: [Адрес] [Телефон] [Комментарий] [Дата].
   - `callback_data` для кнопок: `order_edit_{orderId}_stop_1_address`, `_stop_1_phone`, `_stop_1_comment`, и для даты — например `order_edit_{orderId}_date`.
3. Если точек несколько:
   - Сначала отправить: «Какую точку редактировать?» и кнопки: [Точка 1: Анна], [Точка 2: Лена], …
   - `callback_data`: `order_edit_{orderId}_stop_1`, `order_edit_{orderId}_stop_2`, …
4. При нажатии `order_edit_{orderId}_stop_N` (N — номер точки):
   - Показать «Что изменить в точке N?» и кнопки: [Адрес] [Телефон] [Комментарий] с `callback_data`: `order_edit_{orderId}_stop_N_address`, `_stop_N_phone`, `_stop_N_comment`.

Так мы определяем и заказ, и точку, и поле — всё зашито в `callback_data`.

### 3.2. Запомнить «сейчас редактируем это поле» и ждать текст

Когда пользователь нажал, например, «Адрес» для точки 2, мы получили `order_edit_{orderId}_stop_2_address`. Нам нужно:

- Показать сообщение: «Введите новый адрес для точки 2».
- Запомнить в памяти: у пользователя `telegramId` сейчас режим «редактирую заказ orderId, точку 2, поле address».

Хранить это можно в `Map<Long, OrderEditState>`, где ключ — `telegramId`, а значение — объект с полями `orderId`, `stopNumber`, `field` (address/phone/comment/date). Класс можно назвать `OrderEditState` и положить в пакет `model` или рядом с хендлерами.

### 3.3. Обработать текстовое сообщение от пользователя

В `Bot.java` в обработчике текстовых сообщений (где обрабатываются кнопки «Мои заказы», «Создать заказ» и т.д.) нужно добавить проверку в начале:

- Есть ли для данного `telegramId` запись в `Map` (редактирование заказа)?
- Если да — не обрабатывать как обычную команду, а передать текст в отдельный обработчик редактирования заказа (например, `OrderEditHandler.handleText(telegramId, chatId, text)`).

В этом обработчике:

- По `orderId`, `stopNumber`, `field` понять, что обновлять: адрес, телефон или комментарий точки (или дату заказа).
- Вызвать сервис обновления (см. шаг 4), сохранить в БД.
- Удалить состояние из `Map`.
- Написать пользователю «Готово, адрес обновлён» (или телефон/комментарий) и снова показать меню «Что ещё изменить?» для этого заказа (или «Главное меню»).

Для поля «Дата» можно не ввод текста, а снова inline-кнопки [Сегодня] [Завтра] с `callback_data` вида `order_edit_{orderId}_date_today` / `_date_tomorrow` и обработать их в `CallbackQueryHandler`.

Итого: «Редактировать» ведёт в цепочку callback’ов (выбор точки → выбор поля) и один раз — ввод текста, который обрабатывается по состоянию из `Map`.

---

## ШАГ 4: Сервис обновления заказа

**Где:** `OrderService` (или отдельный сервис, если захочешь вынести).

**Что нужно:** методы, которые по id заказа и номеру точки обновляют одно поле и сохраняют:

- `updateStopAddress(orderId, stopNumber, newAddress)` — для точки в `order_stops` обновить адрес. Если нужен пересчёт цены по геокоду — здесь же вызвать геокодер и `DeliveryPriceService`, обновить цену точки и пересчитать общую сумму заказа.
- `updateStopPhone(orderId, stopNumber, newPhone)` — обновить телефон точки.
- `updateStopComment(orderId, stopNumber, newComment)` — обновить комментарий точки.
- `updateOrderDeliveryDate(orderId, newDate)` — обновить дату доставки у самого заказа (одна дата на весь заказ).

Для обычного заказа с одной точкой данные дублируются в таблице `orders` (recipient_name, recipient_phone, delivery_address и т.д.). Нужно решить: хранить ли «источник правды» только в `order_stops`, а в `orders` только для первой точки — тогда при обновлении точки 1 обновлять и поля заказа; или синхронизировать оба места в этих методах. Достаточно в первых версиях обновлять только `order_stops`, а в заказе — только если редактируется точка 1.

---

## Порядок внедрения (чтобы не путаться)

1. **Шаг 1** — добавить под списком «Мои заказы» inline-кнопки (Редактировать / Отменить) и метод отправки сообщения с клавиатурой. Проверить, что кнопки видны и при нажатии приходит callback с нужным `orderId`.
2. **Шаг 2** — в `CallbackQueryHandler` обработать отмену: показ подтверждения и `order_cancel_ok_` / `order_cancel_no`. В `OrderService` добавить метод отмены (установка статуса CANCELLED). Проверить сценарий от начала до конца.
3. **Шаг 4** — реализовать в `OrderService` обновление одного поля точки (например, только комментарий), чтобы потом вызывать из обработчика редактирования.
4. **Шаг 3** — меню «Редактировать» (точки → поля), класс состояния редактирования, обработка callback’ов и одного текстового сообщения. Подключить вызовы сервиса из шага 4.

Так будет понятно, что делать и почему на каждом шаге: сначала кнопки и отмена (без состояния), потом обновление в БД, потом диалог редактирования с состоянием.
