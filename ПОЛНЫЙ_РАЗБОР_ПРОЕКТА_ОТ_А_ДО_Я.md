# 🔥 ПОЛНЫЙ РАЗБОР ПРОЕКТА — ОТ А ДО Я

**Версия:** 1.0 — Тотальное сканирование  
**Автор:** Твой злой наставник  
**Стиль:** Максимальная глубина, чёрный юмор, маты, аналогии на грани

---

# 📋 СОДЕРЖАНИЕ

## ЧАСТЬ 1: ФУНДАМЕНТ
1. [Что такое Spring Boot и почему он охуенен](#spring-boot)
2. [Dependency Injection — как Spring подставляет зависимости](#dependency-injection)
3. [Аннотации — магические слова Spring](#аннотации)
4. [Жизненный цикл приложения](#жизненный-цикл)

## ЧАСТЬ 2: АРХИТЕКТУРА ПРОЕКТА
5. [Слоёная архитектура — почему так](#слоёная-архитектура)
6. [Карта взаимодействий — кто кого дёргает](#карта-взаимодействий)
7. [Пакеты и их назначение](#пакеты)

## ЧАСТЬ 3: БАЗА ДАННЫХ
8. [JPA и Hibernate — ORM на пальцах](#jpa-и-hibernate)
9. [Entity — как Java-класс становится таблицей](#entity)
10. [Repository — магия Spring Data](#repository)

## ЧАСТЬ 4: БИЗНЕС-ЛОГИКА
11. [Service — мозг приложения](#service)
12. [Транзакции — всё или ничего](#транзакции)

## ЧАСТЬ 5: TELEGRAM BOT
13. [Как работает Telegram Bot API](#telegram-bot-api)
14. [Update — входящее событие](#update)
15. [Handler — обработчик команд](#handler)
16. [State Machine — пошаговые диалоги](#state-machine)

## ЧАСТЬ 6: ПРАКТИКА
17. [Как написать новую фичу с нуля](#новая-фича)
18. [Паттерны и антипаттерны](#паттерны)
19. [Отладка и логирование](#отладка)

---

# ЧАСТЬ 1: ФУНДАМЕНТ

---

# SPRING BOOT

## Что это вообще такое?

**Spring** — это фреймворк для Java, который делает разработку в 100 раз проще.  
**Spring Boot** — это Spring на стероидах, где всё настроено из коробки.

### Без Spring (говнокод):

```java
// Создаём подключение к БД вручную
Connection conn = DriverManager.getConnection("jdbc:postgresql://...", "user", "pass");

// Создаём репозиторий вручную
UserRepository userRepo = new UserRepositoryImpl(conn);

// Создаём сервис вручную, передаём репозиторий
UserService userService = new UserServiceImpl(userRepo);

// Создаём хендлер вручную, передаём сервис
StartCommandHandler handler = new StartCommandHandler(userService);

// Создаём бота вручную, передаём хендлер
Bot bot = new Bot(handler);

// И так для каждого ёбаного компонента...
```

**Проблемы:**
- Куча boilerplate кода (код ради кода).
- Если меняется конструктор — нужно менять везде.
- Тестирование — ад.
- Конфигурация — ад.

### Со Spring Boot (красота):

```java
@Component
public class Bot {
    private final StartCommandHandler handler; // Spring сам подставит!
    
    public Bot(StartCommandHandler handler) {
        this.handler = handler;
    }
}
```

**Spring делает:**
1. Находит все классы с аннотациями (`@Component`, `@Service`, и т.д.).
2. Создаёт их экземпляры.
3. Смотрит, что им нужно (зависимости в конструкторе).
4. Автоматически подставляет зависимости.
5. Управляет жизненным циклом.

**Аналогия:**

Представь, ты приходишь в ресторан.

**Без Spring:** Ты сам идёшь на кухню, сам режешь овощи, сам жаришь мясо, сам моешь посуду. Ебануться!

**Со Spring:** Ты говоришь "хочу стейк", и официант (Spring) приносит готовое блюдо. Тебе похуй, откуда мясо, кто его готовил — ты просто ешь.

---

# DEPENDENCY INJECTION

## Что это такое?

**Dependency Injection (DI)** — это когда зависимости **передаются снаружи**, а не создаются внутри класса.

### Без DI (говнокод):

```java
public class Bot {
    private UserService userService;
    
    public Bot() {
        // Создаём зависимость ВНУТРИ класса
        this.userService = new UserService();
    }
}
```

**Проблемы:**
- `Bot` намертво привязан к `UserService`.
- Нельзя подменить `UserService` на мок для тестов.
- Если `UserService` требует другие зависимости — придётся их тоже создавать.

### С DI (красота):

```java
public class Bot {
    private final UserService userService;
    
    // Зависимость ПЕРЕДАЁТСЯ снаружи
    public Bot(UserService userService) {
        this.userService = userService;
    }
}
```

**Преимущества:**
- `Bot` не знает, как создаётся `UserService`.
- Можно передать реальный сервис или мок.
- Легко тестировать.

### Как Spring делает DI:

```java
@Component
public class Bot {
    private final UserService userService;
    
    // Spring видит конструктор, находит бин UserService, передаёт сюда
    public Bot(UserService userService) {
        this.userService = userService;
    }
}

@Service
public class UserService {
    // Spring создаёт этот бин
}
```

**Порядок:**
1. Spring сканирует пакеты.
2. Находит `UserService` с аннотацией `@Service`.
3. Создаёт экземпляр `UserService`.
4. Находит `Bot` с аннотацией `@Component`.
5. Смотрит конструктор — нужен `UserService`.
6. Подставляет созданный `UserService` в конструктор `Bot`.
7. Создаёт `Bot`.

**Аналогия:**

**Без DI:** Ты сам строишь дом, сам делаешь кирпичи, сам добываешь глину.

**С DI:** Ты говоришь "хочу дом с 3 спальнями", и тебе его строят. Откуда кирпичи — не твоя проблема.

---

# АННОТАЦИИ

## Что это такое?

**Аннотация** — это метаданные, которые говорят Spring (или другим библиотекам), что делать с классом/методом/полем.

Синтаксис: `@ИмяАннотации` или `@ИмяАннотации(параметры)`.

## Основные аннотации Spring

### @Component

```java
@Component
public class MyClass {
}
```

**Что делает:** Говорит Spring: "Это компонент, создай его экземпляр и положи в контейнер".

**Когда использовать:** Для любого класса, который должен быть бином Spring.

### @Service

```java
@Service
public class UserService {
}
```

**Что делает:** То же самое, что `@Component`, но с семантикой "это сервис (бизнес-логика)".

**Когда использовать:** Для классов с бизнес-логикой.

### @Repository

```java
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {
}
```

**Что делает:** То же самое, что `@Component`, но с семантикой "это репозиторий (доступ к данным)".

**Дополнительно:** Включает преобразование исключений БД в Spring-исключения.

### @Controller / @RestController

```java
@RestController
public class ApiController {
}
```

**Что делает:** Помечает класс как HTTP-контроллер (для REST API). У нас нет — мы бот, не веб-приложение.

### @Autowired

```java
@Autowired
private UserService userService;
```

**Что делает:** Говорит Spring: "Найди бин такого типа и подставь сюда".

**Способы инжекции:**
1. **Через конструктор** (рекомендуется):
   ```java
   public Bot(UserService userService) {
       this.userService = userService;
   }
   ```
2. **Через поле** (не рекомендуется, но иногда нужно):
   ```java
   @Autowired
   private UserService userService;
   ```
3. **Через сеттер** (редко):
   ```java
   @Autowired
   public void setUserService(UserService userService) {
       this.userService = userService;
   }
   ```

**Почему конструктор лучше:**
- Поля можно сделать `final` (защита от случайного изменения).
- Зависимости явные (видно в конструкторе).
- Легче тестировать (передаёшь моки в конструктор).

### @Lazy

```java
@Autowired
@Lazy
private Bot bot;
```

**Что делает:** Откладывает создание бина до первого использования.

**Зачем нужно:** Решает проблему **циклических зависимостей**.

**Циклическая зависимость:**
- `Bot` зависит от `CallbackQueryHandler`.
- `CallbackQueryHandler` зависит от `Bot`.
- Spring охуевает: "Чтобы создать Bot, нужен CallbackQueryHandler. Чтобы создать CallbackQueryHandler, нужен Bot. Бесконечный цикл!"

**С @Lazy:**
- Spring создаёт `CallbackQueryHandler` без `Bot`.
- Вместо `Bot` подставляет **прокси** (заглушку).
- Когда первый раз обращаемся к `bot` — Spring создаёт реальный `Bot`.

### @Value

```java
@Value("${telegram.bot.token}")
private String botToken;
```

**Что делает:** Берёт значение из `application.properties` и подставляет в поле.

**Синтаксис:** `${имя.свойства}` — значение из properties.

**Пример properties:**
```properties
telegram.bot.token=123456:ABC-DEF
```

**Пример использования:**
```java
@Value("${telegram.bot.token}")
private String botToken; // Будет "123456:ABC-DEF"

@Value("${server.port:8080}") // Значение по умолчанию, если нет в properties
private int port;
```

### @Transactional

```java
@Transactional
public void transferMoney(Account from, Account to, int amount) {
    // Всё внутри — одна транзакция
}
```

**Что делает:** Оборачивает метод в транзакцию БД.

**Подробнее:** См. раздел [Транзакции](#транзакции).

---

## Аннотации Lombok

**Lombok** — библиотека, которая генерирует boilerplate код (геттеры, сеттеры, конструкторы).

### @Getter / @Setter

```java
@Getter
@Setter
public class User {
    private String name;
}
```

**Генерирует:**
```java
public String getName() { return name; }
public void setName(String name) { this.name = name; }
```

### @NoArgsConstructor / @AllArgsConstructor

```java
@NoArgsConstructor  // Конструктор без параметров
@AllArgsConstructor // Конструктор со всеми параметрами
public class User {
    private String name;
    private int age;
}
```

**Генерирует:**
```java
public User() {}
public User(String name, int age) {
    this.name = name;
    this.age = age;
}
```

### @RequiredArgsConstructor

```java
@RequiredArgsConstructor
public class Bot {
    private final UserService userService; // final!
    private String tempData; // не final
}
```

**Генерирует конструктор только для `final` полей:**
```java
public Bot(UserService userService) {
    this.userService = userService;
}
```

**Почему это круто для DI:**
- Spring видит конструктор с параметрами.
- Автоматически инжектит зависимости.
- Не нужно писать конструктор руками.

### @Builder

```java
@Builder
public class Shop {
    private String name;
    private String address;
}
```

**Позволяет:**
```java
Shop shop = Shop.builder()
        .name("Цветы")
        .address("ул. Ленина, 10")
        .build();
```

**Зачем:** Удобно создавать объекты с много полями, не заполняя все.

### @Data

```java
@Data
public class ShopRegistrationData {
    private String shopName;
    private String address;
}
```

**Генерирует ВСЁ:**
- `@Getter` для всех полей
- `@Setter` для всех полей
- `@ToString`
- `@EqualsAndHashCode`
- `@RequiredArgsConstructor`

**Когда использовать:** Для DTO и простых классов данных.

### @Slf4j

```java
@Slf4j
public class UserService {
    public void doSomething() {
        log.info("Делаю что-то важное");
        log.error("Пиздец случился", exception);
    }
}
```

**Генерирует:**
```java
private static final Logger log = LoggerFactory.getLogger(UserService.class);
```

**Уровни логирования:**
- `log.trace("...")` — самый детальный (обычно отключён)
- `log.debug("...")` — для отладки
- `log.info("...")` — важные события
- `log.warn("...")` — предупреждения
- `log.error("...")` — ошибки

---

## Аннотации JPA/Hibernate

### @Entity

```java
@Entity
public class User {
}
```

**Что делает:** Говорит JPA: "Это сущность, маппится на таблицу в БД".

### @Table

```java
@Entity
@Table(name = "users")
public class User {
}
```

**Что делает:** Указывает имя таблицы в БД.

**Если не указать:** JPA сам придумает имя (обычно имя класса в snake_case).

### @Id

```java
@Id
private UUID id;
```

**Что делает:** Помечает поле как PRIMARY KEY.

### @GeneratedValue

```java
@Id
@GeneratedValue(strategy = GenerationType.UUID)
private UUID id;
```

**Что делает:** Говорит, как генерировать значение ID.

**Стратегии:**
- `GenerationType.UUID` — генерит UUID (для PostgreSQL).
- `GenerationType.IDENTITY` — использует автоинкремент БД.
- `GenerationType.SEQUENCE` — использует sequence БД.
- `GenerationType.AUTO` — JPA сам решает.

### @Column

```java
@Column(name = "full_name", nullable = false, length = 255)
private String fullName;
```

**Параметры:**
- `name` — имя колонки в БД.
- `nullable` — может ли быть NULL.
- `length` — максимальная длина (для VARCHAR).
- `unique` — уникальное ли значение.
- `precision`, `scale` — для DECIMAL.

### @OneToOne, @OneToMany, @ManyToOne, @ManyToMany

**Связи между таблицами.**

```java
// Один пользователь = один магазин
@OneToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "user_id")
private User user;
```

**FetchType:**
- `LAZY` — загружать связанную сущность только когда обращаемся к ней.
- `EAGER` — загружать сразу вместе с основной сущностью.

**@JoinColumn:**
- `name` — имя колонки с foreign key.

---

# ЖИЗНЕННЫЙ ЦИКЛ

## Что происходит при запуске приложения?

```
1. main() вызывает SpringApplication.run()
         │
         ▼
2. Spring сканирует пакеты (@ComponentScan)
         │
         ▼
3. Находит все классы с @Component, @Service, @Repository, @Controller
         │
         ▼
4. Анализирует зависимости (кто от кого зависит)
         │
         ▼
5. Создаёт бины в правильном порядке (сначала те, от которых зависят)
         │
         ▼
6. Инжектит зависимости (через конструкторы, @Autowired)
         │
         ▼
7. Вызывает @PostConstruct методы (если есть)
         │
         ▼
8. Приложение запущено!
         │
         ▼
9. При остановке: вызывает @PreDestroy методы, закрывает ресурсы
```

## Пример в нашем проекте:

```
1. FlowerDeliveryApplication.main()
         │
         ▼
2. Spring сканирует пакет org.example.flower_delivery
         │
         ▼
3. Находит:
   - Bot (@Component)
   - StartCommandHandler (@Component)
   - CallbackQueryHandler (@Component)
   - ShopRegistrationHandler (@Component)
   - UserService (@Service)
   - ShopService (@Service)
   - UserRepository (@Repository)
   - ShopRepository (@Repository)
         │
         ▼
4. Анализирует зависимости:
   - UserRepository ← ничего не требует
   - ShopRepository ← ничего не требует
   - UserService ← требует UserRepository
   - ShopService ← требует ShopRepository, UserRepository
   - StartCommandHandler ← требует UserService, Bot (lazy)
   - CallbackQueryHandler ← требует UserService, Bot (lazy), ShopRegistrationHandler (lazy)
   - ShopRegistrationHandler ← требует ShopService, Bot (lazy)
   - Bot ← требует StartCommandHandler, CallbackQueryHandler, ShopRegistrationHandler
         │
         ▼
5. Создаёт в порядке:
   1) UserRepository, ShopRepository (нет зависимостей)
   2) UserService (зависит от UserRepository)
   3) ShopService (зависит от ShopRepository, UserRepository)
   4) ShopRegistrationHandler (зависит от ShopService, Bot — lazy прокси)
   5) StartCommandHandler (зависит от UserService, Bot — lazy прокси)
   6) CallbackQueryHandler (зависит от UserService, ShopRegistrationHandler — lazy прокси, Bot — lazy прокси)
   7) Bot (зависит от хендлеров)
         │
         ▼
6. Всё готово!
```

---

# ЧАСТЬ 2: АРХИТЕКТУРА ПРОЕКТА

---

# СЛОЁНАЯ АРХИТЕКТУРА

## Почему именно так?

**Слоёная (layered) архитектура** — это когда приложение разделено на слои, каждый из которых отвечает за своё.

```
┌─────────────────────────────────────────────────────────────┐
│                    TELEGRAM (пользователь)                   │
│                   пишет сообщение / нажимает кнопку          │
└─────────────────────────────┬───────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                         BOT.java                             │
│            Получает Update, распределяет по хендлерам        │
│                    (роутер / диспетчер)                      │
└─────────────────────────────┬───────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    HANDLER (обработчики)                     │
│     StartCommandHandler, CallbackQueryHandler, и т.д.        │
│           Обрабатывают команды, отправляют ответы            │
│                  (presentation layer)                        │
└─────────────────────────────┬───────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    SERVICE (сервисы)                         │
│              UserService, ShopService, и т.д.                │
│        Бизнес-логика: проверки, расчёты, правила             │
│                   (business layer)                           │
└─────────────────────────────┬───────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                  REPOSITORY (репозитории)                    │
│            UserRepository, ShopRepository, и т.д.            │
│         SQL-запросы к БД (генерируются Spring Data)          │
│                    (data access layer)                       │
└─────────────────────────────┬───────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     DATABASE (PostgreSQL)                    │
│                 Таблицы: users, shops, orders                │
│                    (persistence layer)                       │
└─────────────────────────────────────────────────────────────┘
```

## Почему так, а не всё в одном файле?

### Проблема "God Object" (Бог-объект):

```java
// ПЛОХО: Всё в одном классе (5000 строк)
public class Bot {
    public void onUpdateReceived(Update update) {
        // Обработка /start
        // Обработка /help
        // Обработка кнопок
        // SQL-запросы к БД
        // Бизнес-логика
        // Отправка сообщений
        // ВСЁ ЗДЕСЬ, БЛЯТЬ!
    }
}
```

**Проблемы:**
1. **Нечитаемо** — попробуй найти баг в 5000 строках.
2. **Нетестируемо** — как протестировать только бизнес-логику?
3. **Неподдерживаемо** — изменишь одно — сломаешь другое.
4. **Нерасширяемо** — добавить фичу = ещё 500 строк в кашу.

### Решение: Разделение ответственности

```java
// ХОРОШО: Каждый класс делает своё

// Handler — только обработка команд
public class StartCommandHandler {
    public void handle(Update update) {
        userService.registerUser(...); // Делегирует сервису
        sendMessage(...);
    }
}

// Service — только бизнес-логика
public class UserService {
    public User registerUser(Long telegramId, String name) {
        // Проверки, правила, логика
        return userRepository.save(user); // Делегирует репозиторию
    }
}

// Repository — только SQL
public interface UserRepository {
    User save(User user);
    Optional<User> findByTelegramId(Long id);
}
```

**Преимущества:**
1. **Читаемо** — каждый файл 50-200 строк.
2. **Тестируемо** — можно замокать репозиторий и тестировать сервис.
3. **Поддерживаемо** — изменения изолированы.
4. **Расширяемо** — новая фича = новый хендлер + новый сервис.

---

# КАРТА ВЗАИМОДЕЙСТВИЙ

## Кто кого дёргает (полная картина):

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              TELEGRAM                                    │
│                    (отправляет Update в бота)                            │
└────────────────────────────────┬────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                              Bot.java                                    │
│                                                                          │
│  onUpdateReceived(Update update) {                                       │
│      if (update.hasCallbackQuery()) {                                    │
│          callbackQueryHandler.handle(update); ──────────────────────┐    │
│      }                                                               │    │
│      if (update.hasMessage()) {                                      │    │
│          if (shopRegistrationHandler.handleMessage(update)) {        │    │
│              return; ────────────────────────────────────────────┐   │    │
│          }                                                       │   │    │
│          if (text.equals("/start")) {                            │   │    │
│              startCommandHandler.handle(update); ────────────┐   │   │    │
│          }                                                   │   │   │    │
│      }                                                       │   │   │    │
│  }                                                           │   │   │    │
└──────────────────────────────────────────────────────────────┼───┼───┼────┘
                                                               │   │   │
                    ┌──────────────────────────────────────────┘   │   │
                    │                                              │   │
                    ▼                                              │   │
┌─────────────────────────────────────────┐                        │   │
│        StartCommandHandler.java         │                        │   │
│                                         │                        │   │
│  handle(Update update) {                │                        │   │
│      userService.registerOrGet(...); ───┼───┐                    │   │
│      sendWelcomeMessage(...);           │   │                    │   │
│  }                                      │   │                    │   │
└─────────────────────────────────────────┘   │                    │   │
                                              │                    │   │
                    ┌─────────────────────────┘                    │   │
                    │                                              │   │
                    ▼                                              │   │
┌─────────────────────────────────────────┐                        │   │
│           UserService.java              │                        │   │
│                                         │                        │   │
│  registerOrGet(telegramId, name) {      │                        │   │
│      userRepository.findByTelegramId(); ┼───┐                    │   │
│      userRepository.save(user);         │   │                    │   │
│  }                                      │   │                    │   │
│                                         │   │                    │   │
│  updateUserRole(telegramId, role) {     │   │                    │   │
│      userRepository.findByTelegramId(); │   │                    │   │
│      userRepository.save(user);         │   │                    │   │
│  }                                      │   │                    │   │
└─────────────────────────────────────────┘   │                    │   │
                                              │                    │   │
                    ┌─────────────────────────┘                    │   │
                    │                                              │   │
                    ▼                                              │   │
┌─────────────────────────────────────────┐                        │   │
│         UserRepository.java             │                        │   │
│                                         │                        │   │
│  findByTelegramId(Long id) ─────────────┼───┐                    │   │
│  save(User user) ───────────────────────┼───┤                    │   │
│  existsByTelegramId(Long id) ───────────┼───┤                    │   │
└─────────────────────────────────────────┘   │                    │   │
                                              │                    │   │
                    ┌─────────────────────────┘                    │   │
                    │                                              │   │
                    ▼                                              │   │
┌─────────────────────────────────────────┐                        │   │
│              PostgreSQL                 │                        │   │
│                                         │                        │   │
│  SELECT * FROM users WHERE telegram_id=?│                        │   │
│  INSERT INTO users (...) VALUES (...)   │                        │   │
└─────────────────────────────────────────┘                        │   │
                                                                   │   │
                    ┌──────────────────────────────────────────────┘   │
                    │                                                  │
                    ▼                                                  │
┌─────────────────────────────────────────┐                            │
│      CallbackQueryHandler.java          │                            │
│                                         │                            │
│  handle(Update update) {                │                            │
│      if (callbackData.startsWith("role_")) {                         │
│          userService.updateUserRole(...); ──────────────────────┐    │
│          if (role == SHOP) {                                    │    │
│              shopRegistrationHandler.startRegistrationFromCallback(); │
│          }                              │                        │    │
│      }                                  │                        │    │
│  }                                      │                        │    │
└─────────────────────────────────────────┘                        │    │
                                                                   │    │
                    ┌──────────────────────────────────────────────┼────┘
                    │                                              │
                    ▼                                              │
┌─────────────────────────────────────────┐                        │
│     ShopRegistrationHandler.java        │                        │
│                                         │                        │
│  startRegistrationFromCallback(...) {   │                        │
│      shopService.findByUserTelegramId(); ───┐                    │
│      registrationDataMap.put(...);      │   │                    │
│      sendMessage("Введи название");     │   │                    │
│  }                                      │   │                    │
│                                         │   │                    │
│  handleMessage(Update update) {         │   │                    │
│      switch (state) {                   │   │                    │
│          WAITING_SHOP_NAME: ...         │   │                    │
│          WAITING_PICKUP_ADDRESS: ...    │   │                    │
│          WAITING_PHONE:                 │   │                    │
│              shopService.createShopForUser(); ──┐                │
│      }                                  │   │   │                │
│  }                                      │   │   │                │
└─────────────────────────────────────────┘   │   │                │
                                              │   │                │
                    ┌─────────────────────────┘   │                │
                    │                             │                │
                    ▼                             │                │
┌─────────────────────────────────────────┐      │                │
│           ShopService.java              │      │                │
│                                         │      │                │
│  findByUserTelegramId(telegramId) {     │      │                │
│      shopRepository.findByUserTelegramId(); ───┼────┐           │
│  }                                      │      │    │           │
│                                         │      │    │           │
│  createShopForUser(...) {               │◄─────┘    │           │
│      userRepository.findByTelegramId(); ───────────────┐        │
│      shopRepository.findByUser(user);   │           │  │        │
│      shopRepository.save(shop);         │           │  │        │
│  }                                      │           │  │        │
└─────────────────────────────────────────┘           │  │        │
                                                      │  │        │
                    ┌─────────────────────────────────┘  │        │
                    │                                    │        │
                    ▼                                    │        │
┌─────────────────────────────────────────┐             │        │
│         ShopRepository.java             │             │        │
│                                         │             │        │
│  findByUserTelegramId(Long id) ─────────┼────┐        │        │
│  findByUser(User user) ─────────────────┼────┤        │        │
│  save(Shop shop) ───────────────────────┼────┤        │        │
└─────────────────────────────────────────┘    │        │        │
                                               │        │        │
                    ┌──────────────────────────┘        │        │
                    │         ┌─────────────────────────┘        │
                    │         │                                  │
                    ▼         ▼                                  │
┌─────────────────────────────────────────┐                      │
│              PostgreSQL                 │◄─────────────────────┘
│                                         │
│  SELECT * FROM shops WHERE ...          │
│  INSERT INTO shops (...) VALUES (...)   │
│  SELECT * FROM users WHERE ...          │
└─────────────────────────────────────────┘
```

---

# ПАКЕТЫ

## Структура проекта:

```
src/main/java/org/example/flower_delivery/
├── FlowerDeliveryApplication.java   ← Точка входа (main)
├── Bot.java                         ← Главный класс бота
│
├── model/                           ← МОДЕЛИ (сущности)
│   ├── User.java                    ← Пользователь (таблица users)
│   ├── Shop.java                    ← Магазин (таблица shops)
│   ├── Role.java                    ← Enum ролей (COURIER, SHOP, ADMIN)
│   ├── RegistrationState.java       ← Enum шагов регистрации
│   └── ShopRegistrationData.java    ← Данные регистрации (в памяти)
│
├── repository/                      ← РЕПОЗИТОРИИ (доступ к БД)
│   ├── UserRepository.java          ← SQL для users
│   └── ShopRepository.java          ← SQL для shops
│
├── service/                         ← СЕРВИСЫ (бизнес-логика)
│   ├── UserService.java             ← Логика пользователей
│   └── ShopService.java             ← Логика магазинов
│
├── handler/                         ← ОБРАБОТЧИКИ (Telegram)
│   ├── StartCommandHandler.java     ← Обработка /start
│   ├── CallbackQueryHandler.java    ← Обработка кнопок
│   └── ShopRegistrationHandler.java ← Пошаговая регистрация магазина
│
└── config/                          ← КОНФИГУРАЦИЯ
    └── TelegramBotConfig.java       ← Настройки бота
```

## Что где лежит и почему:

### model/ — Модели данных

**Что это:** Классы, которые представляют данные (сущности БД, enum-ы, DTO).

**Правила:**
- Только данные, никакой логики.
- Аннотации JPA (`@Entity`, `@Table`, `@Column`).
- Lombok для boilerplate (`@Getter`, `@Setter`, `@Builder`).

### repository/ — Репозитории

**Что это:** Интерфейсы для доступа к БД.

**Правила:**
- Только интерфейсы, Spring сам создаёт реализацию.
- Наследуются от `JpaRepository<Entity, IdType>`.
- Кастомные методы по имени (`findByTelegramId`).

### service/ — Сервисы

**Что это:** Классы с бизнес-логикой.

**Правила:**
- Вся логика здесь (проверки, расчёты, правила).
- Дёргают репозитории для доступа к данным.
- Помечаются `@Service`.
- Методы могут быть `@Transactional`.

### handler/ — Обработчики

**Что это:** Классы, которые обрабатывают события от Telegram.

**Правила:**
- Получают `Update`, извлекают данные.
- Дёргают сервисы для бизнес-логики.
- Отправляют ответы пользователю.
- Помечаются `@Component`.

### config/ — Конфигурация

**Что это:** Классы с настройками Spring.

**Правила:**
- Помечаются `@Configuration`.
- Содержат `@Bean` методы.
- Настройки, которые нельзя сделать через аннотации.

---

# ЧАСТЬ 3: БАЗА ДАННЫХ

---

# JPA И HIBERNATE

## Что это такое?

**JPA (Java Persistence API)** — это спецификация (интерфейс), которая описывает, как работать с БД в Java.

**Hibernate** — это реализация JPA (библиотека, которая делает реальную работу).

**Аналогия:**
- **JPA** — это правила дорожного движения (спецификация).
- **Hibernate** — это водитель, который по этим правилам ездит (реализация).

## Как это работает?

```
Java объект (User)
        │
        ▼
┌───────────────────┐
│     Hibernate     │  ← Преобразует объект в SQL
└───────────────────┘
        │
        ▼
    SQL запрос
        │
        ▼
┌───────────────────┐
│    PostgreSQL     │  ← Выполняет SQL
└───────────────────┘
```

**Пример:**

```java
// Java код:
User user = new User();
user.setFullName("Иван");
userRepository.save(user);

// Hibernate генерирует SQL:
INSERT INTO users (id, full_name, ...) VALUES ('uuid-123', 'Иван', ...);
```

## Зачем ORM?

**Без ORM:**
```java
String sql = "INSERT INTO users (id, full_name, telegram_id) VALUES (?, ?, ?)";
PreparedStatement stmt = connection.prepareStatement(sql);
stmt.setString(1, user.getId().toString());
stmt.setString(2, user.getFullName());
stmt.setLong(3, user.getTelegramId());
stmt.executeUpdate();
```

**С ORM:**
```java
userRepository.save(user);
```

**Профит:**
- Не пишешь SQL руками.
- Не заботишься о типах данных.
- Не боишься SQL-инъекций.
- Легко менять БД (PostgreSQL → MySQL).

---

# ENTITY

## Как Java-класс становится таблицей?

```java
@Entity                              // 1. Это сущность!
@Table(name = "users")               // 2. Имя таблицы
@Getter @Setter                      // 3. Геттеры и сеттеры
@NoArgsConstructor @AllArgsConstructor
@Builder
public class User {

    @Id                              // 4. Это PRIMARY KEY
    @GeneratedValue(strategy = GenerationType.UUID)  // 5. Генерировать UUID
    @Column(name = "id", nullable = false, updatable = false)
    private UUID id;

    @Column(name = "telegram_id", nullable = false, unique = true)
    private Long telegramId;         // 6. Обычная колонка

    @Column(name = "full_name", nullable = false, length = 255)
    private String fullName;

    @Enumerated(EnumType.STRING)     // 7. Enum как строка
    @Column(name = "role", length = 20)
    private Role role;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = false;

    @CreationTimestamp               // 8. Автоматическая дата создания
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp                 // 9. Автоматическая дата обновления
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;
}
```

## Разбор каждой аннотации:

### @Entity
```java
@Entity
```
**Что делает:** Говорит JPA: "Это не просто класс, это сущность. Создай для неё таблицу."

### @Table(name = "users")
```java
@Table(name = "users")
```
**Что делает:** Указывает имя таблицы в БД.

**Если не указать:** JPA возьмёт имя класса (User → user).

### @Id
```java
@Id
private UUID id;
```
**Что делает:** Помечает поле как PRIMARY KEY.

**Правила:**
- В каждой Entity должен быть ровно один `@Id`.
- Может быть составной ключ (`@EmbeddedId`), но это редко.

### @GeneratedValue
```java
@GeneratedValue(strategy = GenerationType.UUID)
```
**Что делает:** Говорит, как генерировать значение ID.

**Стратегии:**
- `UUID` — генерит UUID (наш случай).
- `IDENTITY` — автоинкремент БД (1, 2, 3...).
- `SEQUENCE` — использует sequence PostgreSQL.
- `AUTO` — JPA сам решает.

### @Column
```java
@Column(name = "telegram_id", nullable = false, unique = true)
private Long telegramId;
```
**Параметры:**
- `name` — имя колонки в БД.
- `nullable` — может ли быть NULL (по умолчанию true).
- `unique` — уникальное значение.
- `length` — максимальная длина (для String).
- `updatable` — можно ли обновлять (по умолчанию true).
- `insertable` — можно ли вставлять (по умолчанию true).

### @Enumerated
```java
@Enumerated(EnumType.STRING)
private Role role;
```
**Что делает:** Указывает, как хранить Enum в БД.

**Варианты:**
- `EnumType.STRING` — хранить как строку ("COURIER", "SHOP").
- `EnumType.ORDINAL` — хранить как число (0, 1, 2). НЕ ИСПОЛЬЗОВАТЬ!

**Почему не ORDINAL:**
- Если добавишь новый enum в середину — все значения сломаются.
- `COURIER = 0, SHOP = 1` → добавил `ADMIN` в начало → `ADMIN = 0, COURIER = 1, SHOP = 2`.
- Все курьеры стали админами. Пиздец.

### @CreationTimestamp / @UpdateTimestamp
```java
@CreationTimestamp
private LocalDateTime createdAt;

@UpdateTimestamp
private LocalDateTime updatedAt;
```
**Что делают:**
- `@CreationTimestamp` — автоматически ставит текущее время при INSERT.
- `@UpdateTimestamp` — автоматически обновляет время при UPDATE.

---

# REPOSITORY

## Как Spring Data генерирует SQL?

```java
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {

    // Spring сам генерирует SQL!
    
    Optional<User> findByTelegramId(Long telegramId);
    // SELECT * FROM users WHERE telegram_id = ?
    
    boolean existsByTelegramId(Long telegramId);
    // SELECT COUNT(*) > 0 FROM users WHERE telegram_id = ?
    
    List<User> findByRole(Role role);
    // SELECT * FROM users WHERE role = ?
    
    List<User> findByIsActiveTrue();
    // SELECT * FROM users WHERE is_active = true
    
    Optional<User> findByTelegramIdAndRole(Long telegramId, Role role);
    // SELECT * FROM users WHERE telegram_id = ? AND role = ?
}
```

## Правила именования методов:

| Префикс | Что делает | Пример |
|---------|------------|--------|
| `findBy...` | SELECT | `findByTelegramId(Long id)` |
| `existsBy...` | EXISTS | `existsByTelegramId(Long id)` |
| `countBy...` | COUNT | `countByRole(Role role)` |
| `deleteBy...` | DELETE | `deleteByTelegramId(Long id)` |

| Суффикс | Что делает | Пример |
|---------|------------|--------|
| `...And...` | AND | `findByNameAndAge(...)` |
| `...Or...` | OR | `findByNameOrEmail(...)` |
| `...OrderBy...Asc/Desc` | ORDER BY | `findByRoleOrderByCreatedAtDesc(...)` |
| `...IsTrue/IsFalse` | = true/false | `findByIsActiveTrue()` |
| `...IsNull/IsNotNull` | IS NULL | `findByPhoneIsNull()` |
| `...In` | IN | `findByRoleIn(List<Role> roles)` |
| `...Between` | BETWEEN | `findByCreatedAtBetween(start, end)` |

## Встроенные методы JpaRepository:

```java
// Все эти методы уже есть!

userRepository.save(user);           // INSERT или UPDATE
userRepository.saveAll(users);       // Batch INSERT/UPDATE
userRepository.findById(id);         // SELECT по ID
userRepository.findAll();            // SELECT * (все записи)
userRepository.deleteById(id);       // DELETE по ID
userRepository.delete(user);         // DELETE по объекту
userRepository.count();              // COUNT(*)
userRepository.existsById(id);       // EXISTS по ID
```

---

# ЧАСТЬ 4: БИЗНЕС-ЛОГИКА

---

# SERVICE

## Что такое сервис?

**Сервис** — это класс, который содержит бизнес-логику. Он:
- Получает данные из репозиториев.
- Применяет правила и проверки.
- Возвращает результат.

## Пример: ShopService

```java
@Service                              // 1. Это сервис!
@RequiredArgsConstructor              // 2. Конструктор для DI
@Slf4j                                // 3. Логирование
@Transactional                        // 4. Транзакции
public class ShopService {

    private final ShopRepository shopRepository;   // 5. Зависимости
    private final UserRepository userRepository;

    // 6. Бизнес-метод
    public Shop createShopForUser(Long telegramId,
                                  String shopName,
                                  String pickupAddress,
                                  String phone) {

        log.info("Создание магазина: telegramId={}, shopName={}", telegramId, shopName);

        // 7. Бизнес-правило: найти пользователя
        User user = userRepository.findByTelegramId(telegramId)
                .orElseThrow(() -> new IllegalStateException(
                        "Пользователь не найден для telegramId=" + telegramId));

        // 8. Бизнес-правило: проверить, что магазина ещё нет
        shopRepository.findByUser(user).ifPresent(existing -> {
            throw new IllegalStateException("У пользователя уже есть магазин");
        });

        // 9. Создание сущности
        Shop shop = Shop.builder()
                .user(user)
                .shopName(shopName)
                .pickupAddress(pickupAddress)
                .phone(phone)
                .isActive(false)
                .build();

        // 10. Сохранение
        Shop saved = shopRepository.save(shop);
        log.info("Магазин создан: shopId={}, userId={}", saved.getId(), user.getId());

        return saved;
    }
}
```

## Разбор по пунктам:

### 1. @Service
```java
@Service
```
Помечает класс как сервис. Spring создаст бин и положит в контейнер.

### 2. @RequiredArgsConstructor
```java
@RequiredArgsConstructor
```
Lombok генерирует конструктор для `final` полей:
```java
public ShopService(ShopRepository shopRepository, UserRepository userRepository) {
    this.shopRepository = shopRepository;
    this.userRepository = userRepository;
}
```

### 3. @Slf4j
```java
@Slf4j
```
Lombok генерирует логгер:
```java
private static final Logger log = LoggerFactory.getLogger(ShopService.class);
```

### 4. @Transactional
```java
@Transactional
```
Все публичные методы класса будут выполняться в транзакции.

### 5. Зависимости
```java
private final ShopRepository shopRepository;
private final UserRepository userRepository;
```
- `final` — поле не может быть изменено после инициализации.
- Spring инжектит через конструктор.

### 6-10. Бизнес-логика
- Логирование входных данных.
- Поиск пользователя (если нет — исключение).
- Проверка, что магазина нет (если есть — исключение).
- Создание объекта через Builder.
- Сохранение в БД.
- Логирование результата.

---

# ТРАНЗАКЦИИ

## Что это такое?

**Транзакция** — это набор операций, которые выполняются **атомарно**: либо все успешно, либо все откатываются.

## Пример проблемы без транзакции:

```java
public void transferMoney(Account from, Account to, int amount) {
    from.setBalance(from.getBalance() - amount);
    accountRepository.save(from);  // Сохранили списание
    
    // БАЦ! Сервер упал!
    
    to.setBalance(to.getBalance() + amount);
    accountRepository.save(to);  // Не выполнилось!
}
// Результат: деньги списались, но не зачислились. Пиздец.
```

## С транзакцией:

```java
@Transactional
public void transferMoney(Account from, Account to, int amount) {
    from.setBalance(from.getBalance() - amount);
    accountRepository.save(from);
    
    // БАЦ! Сервер упал!
    
    to.setBalance(to.getBalance() + amount);
    accountRepository.save(to);
}
// Результат: транзакция откатилась, оба счёта без изменений.
```

## Когда происходит commit/rollback:

- **Commit** — когда метод успешно завершился (return).
- **Rollback** — когда метод кинул **unchecked exception** (RuntimeException).

```java
@Transactional
public void doSomething() {
    shopRepository.save(shop);
    
    if (somethingWrong) {
        throw new RuntimeException("Пиздец!"); // Rollback!
    }
    
    // Если дошли сюда — commit
}
```

---

# ЧАСТЬ 5: TELEGRAM BOT

---

# TELEGRAM BOT API

## Как работает бот?

```
┌─────────────────┐         ┌─────────────────┐         ┌─────────────────┐
│                 │         │                 │         │                 │
│   Пользователь  │ ──────► │     Telegram    │ ──────► │     Наш бот     │
│                 │         │     Servers     │         │                 │
│   (телефон)     │ ◄────── │                 │ ◄────── │   (Java app)    │
│                 │         │                 │         │                 │
└─────────────────┘         └─────────────────┘         └─────────────────┘
     Юзер пишет              Telegram хранит             Бот получает
     "/start"                и пересылает               Update, отвечает
```

## Long Polling vs Webhook:

### Long Polling (наш способ):
```
Бот: "Telegram, есть новые сообщения?"
Telegram: "Нет."
Бот: "А теперь?"
Telegram: "Нет."
Бот: "А теперь?"
Telegram: "Да, вот Update!"
Бот: "Обрабатываю... А теперь есть новые?"
...
```

**Плюсы:**
- Просто настроить (не нужен HTTPS, домен).
- Работает за NAT/firewall.

**Минусы:**
- Постоянные запросы (трафик).
- Небольшая задержка.

### Webhook (продвинутый способ):
```
Бот: "Telegram, когда будет сообщение — отправь на https://mybot.com/webhook"
Telegram: "Ок."
...
(Юзер пишет сообщение)
Telegram: *отправляет POST запрос на https://mybot.com/webhook*
Бот: *получает, обрабатывает*
```

**Плюсы:**
- Мгновенная доставка.
- Меньше трафика.

**Минусы:**
- Нужен HTTPS-сервер с доменом.
- Сложнее настроить.

---

# UPDATE

## Что это такое?

**Update** — это объект, который Telegram отправляет боту при любом событии:
- Новое сообщение.
- Нажатие на кнопку (CallbackQuery).
- Редактирование сообщения.
- И т.д.

## Структура Update:

```java
Update update = ...;

// Есть ли текстовое сообщение?
if (update.hasMessage() && update.getMessage().hasText()) {
    Message message = update.getMessage();
    
    Long chatId = message.getChatId();           // ID чата
    Long userId = message.getFrom().getId();     // ID пользователя
    String text = message.getText();             // Текст сообщения
    String firstName = message.getFrom().getFirstName();  // Имя
}

// Есть ли нажатие на кнопку?
if (update.hasCallbackQuery()) {
    CallbackQuery callback = update.getCallbackQuery();
    
    String callbackData = callback.getData();    // Данные кнопки
    Long userId = callback.getFrom().getId();    // ID пользователя
    Long chatId = callback.getMessage().getChatId();  // ID чата
}
```

## Типы событий в Update:

| Метод | Что проверяет |
|-------|---------------|
| `hasMessage()` | Есть ли сообщение |
| `hasCallbackQuery()` | Есть ли нажатие на inline-кнопку |
| `hasEditedMessage()` | Редактирование сообщения |
| `hasChannelPost()` | Пост в канале |
| `hasMyChatMember()` | Изменение статуса бота в чате |

---

# HANDLER

## Что это такое?

**Handler** — это класс, который обрабатывает определённый тип событий от Telegram.

## Пример: StartCommandHandler

```java
@Slf4j
@Component
@RequiredArgsConstructor
public class StartCommandHandler {

    private final UserService userService;
    
    @Autowired
    @Lazy
    private Bot bot;

    /**
     * Обработать команду /start
     */
    public void handle(Update update) {
        // 1. Извлекаем данные из Update
        Long chatId = update.getMessage().getChatId();
        Long telegramId = update.getMessage().getFrom().getId();
        String firstName = update.getMessage().getFrom().getFirstName();

        log.info("Команда /start от пользователя: telegramId={}, firstName={}", 
                telegramId, firstName);

        // 2. Бизнес-логика (через сервис)
        userService.registerOrGetUser(telegramId, firstName);

        // 3. Отправляем ответ
        sendWelcomeMessage(chatId, firstName);
    }

    private void sendWelcomeMessage(Long chatId, String firstName) {
        // Создаём клавиатуру с кнопками
        InlineKeyboardMarkup keyboard = InlineKeyboardMarkup.builder()
                .keyboardRow(List.of(
                        InlineKeyboardButton.builder()
                                .text("🏪 Магазин")
                                .callbackData("role_shop")
                                .build(),
                        InlineKeyboardButton.builder()
                                .text("🚴 Курьер")
                                .callbackData("role_courier")
                                .build()
                ))
                .build();

        // Создаём сообщение
        SendMessage message = SendMessage.builder()
                .chatId(chatId.toString())
                .text("Привет, " + firstName + "! 👋\n\nВыбери свою роль:")
                .replyMarkup(keyboard)
                .parseMode("Markdown")
                .build();

        // Отправляем
        try {
            bot.execute(message);
        } catch (TelegramApiException e) {
            log.error("Ошибка отправки сообщения", e);
        }
    }
}
```

## Паттерн обработчика:

1. **Извлечь данные** из Update (chatId, userId, text).
2. **Вызвать сервис** для бизнес-логики.
3. **Сформировать ответ** (текст, кнопки).
4. **Отправить** через `bot.execute()`.

---

# STATE MACHINE

## Что это такое?

**State Machine (конечный автомат)** — это способ управления пошаговыми диалогами.

## Проблема:

```
Бот: "Введи название магазина"
Юзер: "Цветы на Ленина"
Бот: "Введи адрес"
Юзер: "ул. Ленина, 10"
```

**Как бот понимает**, что "ул. Ленина, 10" — это адрес, а не название?

## Решение: запоминать состояние

```java
// Enum состояний
public enum RegistrationState {
    NONE,                    // Не в процессе регистрации
    WAITING_SHOP_NAME,       // Ждём название
    WAITING_PICKUP_ADDRESS,  // Ждём адрес
    WAITING_PHONE            // Ждём телефон
}

// Данные регистрации
public class ShopRegistrationData {
    private RegistrationState state = NONE;
    private String shopName;
    private String pickupAddress;
    private String phone;
}

// Хранилище состояний (telegramId -> данные)
Map<Long, ShopRegistrationData> registrationDataMap = new ConcurrentHashMap<>();
```

## Как это работает:

```
1. Юзер нажимает "Магазин"
   │
   ▼
2. Создаём ShopRegistrationData, state = WAITING_SHOP_NAME
   registrationDataMap.put(telegramId, data)
   │
   ▼
3. Бот: "Введи название"
   │
   ▼
4. Юзер: "Цветы на Ленина"
   │
   ▼
5. handleMessage():
   - Смотрим registrationDataMap.get(telegramId)
   - state = WAITING_SHOP_NAME
   - Сохраняем: data.setShopName("Цветы на Ленина")
   - Переход: data.setState(WAITING_PICKUP_ADDRESS)
   │
   ▼
6. Бот: "Введи адрес"
   │
   ▼
7. Юзер: "ул. Ленина, 10"
   │
   ▼
8. handleMessage():
   - state = WAITING_PICKUP_ADDRESS
   - Сохраняем: data.setPickupAddress("ул. Ленина, 10")
   - Переход: data.setState(WAITING_PHONE)
   │
   ▼
... и так далее
```

## Код обработки:

```java
public boolean handleMessage(Update update) {
    Long telegramId = update.getMessage().getFrom().getId();
    String text = update.getMessage().getText();

    // Получаем данные юзера
    ShopRegistrationData data = registrationDataMap.get(telegramId);
    
    // Если нет данных или state = NONE — юзер не в процессе регистрации
    if (data == null || data.getState() == RegistrationState.NONE) {
        return false; // Не наш клиент
    }

    // Обрабатываем в зависимости от состояния
    switch (data.getState()) {
        case WAITING_SHOP_NAME:
            data.setShopName(text);
            data.setState(RegistrationState.WAITING_PICKUP_ADDRESS);
            sendMessage(chatId, "Теперь введи адрес:");
            break;
            
        case WAITING_PICKUP_ADDRESS:
            data.setPickupAddress(text);
            data.setState(RegistrationState.WAITING_PHONE);
            sendMessage(chatId, "Теперь введи телефон:");
            break;
            
        case WAITING_PHONE:
            data.setPhone(text);
            // Создаём магазин
            shopService.createShopForUser(...);
            // Очищаем данные
            registrationDataMap.remove(telegramId);
            sendMessage(chatId, "Магазин создан!");
            break;
    }

    return true; // Сообщение обработано
}
```

---

# ЧАСТЬ 6: ПРАКТИКА

---

# НОВАЯ ФИЧА

## Как добавить новую команду с нуля?

**Задача:** Добавить команду `/my_shop` — показать информацию о магазине.

### Шаг 1: Подумай, что нужно

- Найти магазин по telegramId.
- Вернуть информацию (название, адрес, телефон).
- Если магазина нет — сообщить об этом.

### Шаг 2: Добавь метод в сервис (если нужно)

```java
// ShopService.java

public Optional<Shop> findByUserTelegramId(Long telegramId) {
    return shopRepository.findByUserTelegramId(telegramId);
}
```

### Шаг 3: Создай обработчик

```java
// handler/MyShopCommandHandler.java

@Slf4j
@Component
@RequiredArgsConstructor
public class MyShopCommandHandler {

    private final ShopService shopService;
    
    @Autowired
    @Lazy
    private Bot bot;

    public void handle(Update update) {
        Long chatId = update.getMessage().getChatId();
        Long telegramId = update.getMessage().getFrom().getId();

        log.info("Команда /my_shop от пользователя: telegramId={}", telegramId);

        // Ищем магазин
        Optional<Shop> shopOpt = shopService.findByUserTelegramId(telegramId);

        if (shopOpt.isEmpty()) {
            sendMessage(chatId, "❌ У тебя нет магазина.\n\n" +
                    "Нажми /start чтобы зарегистрироваться.");
            return;
        }

        Shop shop = shopOpt.get();
        String text = String.format(
                "🏪 *Твой магазин*\n\n" +
                "📋 Название: %s\n" +
                "📍 Адрес: %s\n" +
                "📞 Телефон: %s\n" +
                "✅ Статус: %s",
                shop.getShopName(),
                shop.getPickupAddress(),
                shop.getPhone() != null ? shop.getPhone() : "не указан",
                shop.getIsActive() ? "Активен" : "Ожидает активации"
        );

        sendMessage(chatId, text);
    }

    private void sendMessage(Long chatId, String text) {
        try {
            bot.execute(SendMessage.builder()
                    .chatId(chatId.toString())
                    .text(text)
                    .parseMode("Markdown")
                    .build());
        } catch (TelegramApiException e) {
            log.error("Ошибка отправки сообщения", e);
        }
    }
}
```

### Шаг 4: Добавь маршрут в Bot.java

```java
// Bot.java

private final MyShopCommandHandler myShopCommandHandler; // Добавь поле

@Override
public void onUpdateReceived(Update update) {
    // ... существующий код ...
    
    if (update.hasMessage() && update.getMessage().hasText()) {
        String text = update.getMessage().getText();
        
        // ... существующие проверки ...
        
        if (text.equals("/my_shop")) {
            myShopCommandHandler.handle(update);
        }
    }
}
```

### Шаг 5: Протестируй

1. Запусти бот.
2. Напиши `/my_shop`.
3. Проверь, что работает.

---

# ПАТТЕРНЫ

## Хорошие практики:

### 1. Single Responsibility Principle (SRP)

**Каждый класс делает одно дело.**

```java
// ПЛОХО: Сервис и отправка сообщений в одном классе
public class UserService {
    public void registerUser(...) { ... }
    public void sendWelcomeMessage(...) { ... } // Не его работа!
}

// ХОРОШО: Сервис только для бизнес-логики
public class UserService {
    public void registerUser(...) { ... }
}

// Отправка сообщений — в хендлере
public class StartCommandHandler {
    public void sendWelcomeMessage(...) { ... }
}
```

### 2. Dependency Injection

**Не создавай зависимости внутри класса.**

```java
// ПЛОХО:
public class Bot {
    private UserService userService = new UserService(); // Жёстко привязан!
}

// ХОРОШО:
public class Bot {
    private final UserService userService;
    
    public Bot(UserService userService) {
        this.userService = userService; // Передан снаружи
    }
}
```

### 3. Optional вместо null

**Не возвращай null, используй Optional.**

```java
// ПЛОХО:
public User findByTelegramId(Long id) {
    User user = ...;
    return user; // Может быть null!
}

// Использование:
User user = userService.findByTelegramId(id);
if (user != null) { // Легко забыть проверку!
    ...
}

// ХОРОШО:
public Optional<User> findByTelegramId(Long id) {
    return Optional.ofNullable(...);
}

// Использование:
userService.findByTelegramId(id)
        .ifPresent(user -> { ... });  // Явно видно, что может не быть

// Или:
User user = userService.findByTelegramId(id)
        .orElseThrow(() -> new RuntimeException("User not found"));
```

### 4. Логирование

**Логируй всё важное.**

```java
// На входе:
log.info("Создание магазина: telegramId={}, shopName={}", telegramId, shopName);

// На выходе:
log.info("Магазин создан: shopId={}", shop.getId());

// При ошибке:
log.error("Ошибка создания магазина: telegramId={}", telegramId, exception);
```

---

# ОТЛАДКА

## Как найти баг?

### 1. Смотри логи

```
2026-01-26 14:01:57.299 DEBUG ... Hibernate: SELECT * FROM users WHERE telegram_id=?
2026-01-26 14:01:57.317 WARN  ... Пользователь с telegramId=123 уже зарегистрирован
2026-01-26 14:01:57.320 DEBUG ... Пользователь уже зарегистрирован: telegramId=123
```

### 2. Добавь логирование

```java
log.debug("Входные данные: telegramId={}, text={}", telegramId, text);
log.debug("Состояние: state={}", data.getState());
log.debug("После обработки: shopName={}", data.getShopName());
```

### 3. Используй отладчик (debugger)

1. Поставь breakpoint (красная точка слева от строки).
2. Запусти в режиме Debug (зелёный жук).
3. Когда выполнение дойдёт до breakpoint — посмотри переменные.

### 4. Проверь БД

```sql
-- Посмотри, что в таблице users
SELECT * FROM users;

-- Посмотри, что в таблице shops
SELECT * FROM shops;

-- Посмотри связь
SELECT u.telegram_id, s.shop_name 
FROM users u 
LEFT JOIN shops s ON u.id = s.user_id;
```

---

# 🎯 ИТОГО

## Что ты должен запомнить:

1. **Spring Boot** — создаёт бины, инжектит зависимости, управляет жизненным циклом.

2. **Слоёная архитектура** — Handler → Service → Repository → Database.

3. **Аннотации** — магические слова, которые говорят Spring что делать.

4. **JPA/Hibernate** — превращает Java-объекты в SQL и обратно.

5. **Repository** — генерирует SQL из имени метода.

6. **Service** — содержит бизнес-логику, работает в транзакциях.

7. **Handler** — обрабатывает события от Telegram, дёргает сервисы.

8. **State Machine** — для пошаговых диалогов (запоминай состояние).

9. **Логирование** — пиши логи везде, потом скажешь себе спасибо.

10. **Optional** — используй вместо null.

---

**Теперь ты знаешь достаточно, чтобы писать код самостоятельно. Иди и твори, блять!** 🚀
